/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Web-API
 * Access Sponge powered Minecraft servers through a WebAPI  # Introduction This is the documentation of the various API routes offered by the WebAPI plugin.  This documentation assumes that you are familiar with the basic concepts of Web API's, such as `GET`, `PUT`, `POST` and `DELETE` methods, request `HEADERS` and `RESPONSE CODES` and `JSON` data.  By default this documentation can be found at http:/localhost:8080 (while your minecraft server is running) and the various routes start with http:/localhost:8080/api/v5...  As a quick test try reaching the route http:/localhost:8080/api/v5/info (remember that you can only access \\\"localhost\\\" routes on the server on which you are running minecraft). This route should show you basic information about your server, like the motd and player count.  # List endpoints Lots of objects offer an endpoint to list all objects (e.g. `GET: /world` to get all worlds). These endpoints return only the properties marked 'required' by default, because the list might be quite large. If you want to return ALL data for a list endpoint add the query parameter `details`, (e.g. `GET: /world?details`).  > Remember that in this case the data returned by the endpoint might be quite large.  # Debugging endpoints Apart from the `?details` flag you can also pass some other flags for debugging purposes. Remember that you must include the first query parameter with `?`, and further ones with `&`:  `details`: Includes details for list endpoints  `accept=[json/xml]`: Manually set the accept content type. This is good for browser testing, **BUT DON'T USE THIS IN PRODUCTION, YOU CAN SUPPLY THE `Accepts` HEADER FOR THAT**  `pretty`: Pretty prints the data, also good for debugging in the browser.  An example request might look like this: `http://localhost:8080/api/v5/world?details&accpet=json&pretty&key=MY-API-KEY`  # Additional data Certain endpoints (such as `/player`, `/entity` and `/tile-entity` have additional properties which are not documented here, because the data depends on the concrete object type (eg. `Sheep` have a wool color, others do not) and on the other plugins/mods that are running on your server which might add additional data.  You can also find more information in the github docs (https:/github.com/Valandur/Web-API/tree/master/docs/DATA.md)
 *
 * OpenAPI spec version: @version@
 * Contact: inithilian@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api/v5".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AcceptsItems
 */
export interface AcceptsItems {
    /**
     * 
     * @type {string}
     * @memberof AcceptsItems
     */
    operator?: AcceptsItems.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof AcceptsItems
     */
    key?: string;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof AcceptsItems
     */
    value?: Array<CatalogType>;
}

/**
 * @export
 * @namespace AcceptsItems
 */
export namespace AcceptsItems {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Account
     */
    balances?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    friendlyId?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface Advancement
 */
export interface Advancement {
    /**
     * The unique id of the advancement
     * @type {string}
     * @memberof Advancement
     */
    id: string;
    /**
     * The name of the advancement
     * @type {string}
     * @memberof Advancement
     */
    name: string;
    /**
     * The title of the advancement
     * @type {string}
     * @memberof Advancement
     */
    title: string;
    /**
     * True if the achieving of this advancement is announced in chat, false otherwise
     * @type {boolean}
     * @memberof Advancement
     */
    announceToChat?: boolean;
    /**
     * The description of the advancement
     * @type {string}
     * @memberof Advancement
     */
    description?: string;
    /**
     * True if this is a hidden advancement
     * @type {boolean}
     * @memberof Advancement
     */
    hidden?: boolean;
    /**
     * The parent advancement, which must be unlocked prior to this advancement
     * @type {Advancement}
     * @memberof Advancement
     */
    parent?: Advancement;
    /**
     * True if achieving this advancement shows the player a toast message, false otherwise
     * @type {boolean}
     * @memberof Advancement
     */
    showToast?: boolean;
    /**
     * The advancement tree that this advancement belongs to
     * @type {CatalogTypeAdvancementTree}
     * @memberof Advancement
     */
    tree?: CatalogTypeAdvancementTree;
}

/**
 * 
 * @export
 * @interface AgeableData
 */
export interface AgeableData {
    /**
     * True if this entity is an adult, false otherwise
     * @type {boolean}
     * @memberof AgeableData
     */
    adult: boolean;
    /**
     * The age of the entity
     * @type {number}
     * @memberof AgeableData
     */
    age: number;
}

/**
 * 
 * @export
 * @interface ArmorSlotType
 */
export interface ArmorSlotType {
    /**
     * 
     * @type {string}
     * @memberof ArmorSlotType
     */
    operator?: ArmorSlotType.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof ArmorSlotType
     */
    key?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof ArmorSlotType
     */
    value?: CatalogType;
}

/**
 * @export
 * @namespace ArmorSlotType
 */
export namespace ArmorSlotType {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface ArmorStandData
 */
export interface ArmorStandData {
    /**
     * True if the armor stand has arms, false otherwise
     * @type {boolean}
     * @memberof ArmorStandData
     */
    arms: boolean;
    /**
     * True if the armor stand has a base plate, false otherwise
     * @type {boolean}
     * @memberof ArmorStandData
     */
    basePlate: boolean;
    /**
     * True if the armor stand has a marker, false otherwise
     * @type {boolean}
     * @memberof ArmorStandData
     */
    marker: boolean;
    /**
     * True if the armor stand is small, false otherwise
     * @type {boolean}
     * @memberof ArmorStandData
     */
    small: boolean;
}

/**
 * 
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * The password of the user
     * @type {string}
     * @memberof AuthenticationRequest
     */
    password: string;
    /**
     * The username of the user
     * @type {string}
     * @memberof AuthenticationRequest
     */
    username: string;
}

/**
 * 
 * @export
 * @interface BannerData
 */
export interface BannerData {
    /**
     * The color of the banner
     * @type {DyeColor}
     * @memberof BannerData
     */
    color: DyeColor;
    /**
     * The patterns on the banner
     * @type {Array<PatternLayer>}
     * @memberof BannerData
     */
    patterns: Array<PatternLayer>;
}

/**
 * 
 * @export
 * @interface BeaconData
 */
export interface BeaconData {
    /**
     * The primary effect of the beacon
     * @type {CatalogType}
     * @memberof BeaconData
     */
    primary?: CatalogType;
    /**
     * The secondary effect of the beacon
     * @type {CatalogType}
     * @memberof BeaconData
     */
    secondary?: CatalogType;
}

/**
 * 
 * @export
 * @interface BlockOperation
 */
export interface BlockOperation {
    /**
     * The error message, if any
     * @type {string}
     * @memberof BlockOperation
     */
    error: string;
    /**
     * The estimated amount of time remaining until this block operation is complete (in seconds)
     * @type {number}
     * @memberof BlockOperation
     */
    estimatedSecondsRemaining: number;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof BlockOperation
     */
    link: string;
    /**
     * The maximum block belonging to this operation
     * @type {Vector3i}
     * @memberof BlockOperation
     */
    max: Vector3i;
    /**
     * The minimum block belonging to this operation
     * @type {Vector3i}
     * @memberof BlockOperation
     */
    min: Vector3i;
    /**
     * The current progress of the block operation, from 0 (=started) to 1 (=finished)
     * @type {number}
     * @memberof BlockOperation
     */
    progress: number;
    /**
     * The current status of the block operation
     * @type {string}
     * @memberof BlockOperation
     */
    status: BlockOperation.StatusEnum;
    /**
     * The type of block operation
     * @type {string}
     * @memberof BlockOperation
     */
    type: BlockOperation.TypeEnum;
    /**
     * The unique UUID identifying this block operation
     * @type {string}
     * @memberof BlockOperation
     */
    uuid: string;
    /**
     * The world in which this block operation is running
     * @type {World}
     * @memberof BlockOperation
     */
    world: World;
}

/**
 * @export
 * @namespace BlockOperation
 */
export namespace BlockOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        INIT = <any> 'INIT',
        RUNNING = <any> 'RUNNING',
        PAUSED = <any> 'PAUSED',
        DONE = <any> 'DONE',
        ERRORED = <any> 'ERRORED',
        CANCELED = <any> 'CANCELED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GET = <any> 'GET',
        CHANGE = <any> 'CHANGE'
    }
}

/**
 * 
 * @export
 * @interface BlockState
 */
export interface BlockState {
    /**
     * Additional data attached to the block state
     * @type {{ [key: string]: any; }}
     * @memberof BlockState
     */
    data?: { [key: string]: any; };
    /**
     * The type of block this block state is from
     * @type {CatalogType}
     * @memberof BlockState
     */
    type?: CatalogType;
}

/**
 * 
 * @export
 * @interface BreathingData
 */
export interface BreathingData {
    /**
     * The maximum amount of air available to this entity
     * @type {number}
     * @memberof BreathingData
     */
    max: number;
    /**
     * The amount of air currently remaining
     * @type {number}
     * @memberof BreathingData
     */
    remaining: number;
}

/**
 * 
 * @export
 * @interface BrewingStandData
 */
export interface BrewingStandData {
    /**
     * The time remaining until brewing is complete
     * @type {number}
     * @memberof BrewingStandData
     */
    remainingBrewTime: number;
}

/**
 * 
 * @export
 * @interface CachedObject
 */
export interface CachedObject {
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof CachedObject
     */
    link: string;
}

/**
 * 
 * @export
 * @interface Career
 */
export interface Career {
    /**
     * The unique id of the career
     * @type {string}
     * @memberof Career
     */
    id: string;
    /**
     * The name of the career
     * @type {string}
     * @memberof Career
     */
    name: string;
    /**
     * The profession within the career
     * @type {CatalogType}
     * @memberof Career
     */
    profession: CatalogType;
}

/**
 * 
 * @export
 * @interface CatalogType
 */
export interface CatalogType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeAdvancementTree
 */
export interface CatalogTypeAdvancementTree {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeAdvancementTree
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeAdvancementTree
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeCurrency
 */
export interface CatalogTypeCurrency {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeCurrency
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeCurrency
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeDifficulty
 */
export interface CatalogTypeDifficulty {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeDifficulty
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeDifficulty
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeDimensionType
 */
export interface CatalogTypeDimensionType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeDimensionType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeDimensionType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeEntityType
 */
export interface CatalogTypeEntityType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeEntityType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeEntityType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeGameMode
 */
export interface CatalogTypeGameMode {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeGameMode
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeGameMode
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeGeneratorType
 */
export interface CatalogTypeGeneratorType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeGeneratorType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeGeneratorType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeInventoryArchetype
 */
export interface CatalogTypeInventoryArchetype {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeInventoryArchetype
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeInventoryArchetype
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeItemType
 */
export interface CatalogTypeItemType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeItemType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeItemType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeSoundType
 */
export interface CatalogTypeSoundType {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeSoundType
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeSoundType
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CatalogTypeWeather
 */
export interface CatalogTypeWeather {
    /**
     * The unique id that indexes this catalog type
     * @type {string}
     * @memberof CatalogTypeWeather
     */
    id: string;
    /**
     * The name of the catalog type
     * @type {string}
     * @memberof CatalogTypeWeather
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Cause
 */
export interface Cause {
    /**
     * The direct sources of this cause
     * @type {Array<any>}
     * @memberof Cause
     */
    causes: Array<any>;
    /**
     * The context surrounding the cause
     * @type {{ [key: string]: any; }}
     * @memberof Cause
     */
    context: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface Chunk
 */
export interface Chunk {
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof Chunk
     */
    link: string;
    /**
     * True if this chunk is currently loaded, false otherwise
     * @type {boolean}
     * @memberof Chunk
     */
    loaded: boolean;
    /**
     * The position of this chunk (in chunk coordinates)
     * @type {Vector3i}
     * @memberof Chunk
     */
    position: Vector3i;
    /**
     * The unique id of this chunk
     * @type {string}
     * @memberof Chunk
     */
    uuid: string;
    /**
     * The bock with the largest coordinates that is still part of this chunk
     * @type {Vector3i}
     * @memberof Chunk
     */
    blockMax?: Vector3i;
    /**
     * The bock with the smallest coordinates that is still part of this chunk
     * @type {Vector3i}
     * @memberof Chunk
     */
    blockMin?: Vector3i;
    /**
     * The total amount of time (in server ticks) this chunk has been inhabited by players.
     * @type {number}
     * @memberof Chunk
     */
    inhabitedTime?: number;
    /**
     * The increase in difficulty due to the presence of players in the chunk
     * @type {number}
     * @memberof Chunk
     */
    regionalDifficultyFactor?: number;
    /**
     * The increase in difficulty due to the presence of players in the chunk as a percentage
     * @type {number}
     * @memberof Chunk
     */
    regionalDifficultyPercentage?: number;
    /**
     * The world the chunk is in
     * @type {World}
     * @memberof Chunk
     */
    world?: World;
}

/**
 * 
 * @export
 * @interface Color
 */
export interface Color {
    /**
     * The red value of the color
     * @type {number}
     * @memberof Color
     */
    r: number;
    /**
     * The green value of the color
     * @type {number}
     * @memberof Color
     */
    g: number;
    /**
     * The blue value of the color
     * @type {number}
     * @memberof Color
     */
    b: number;
}

/**
 * 
 * @export
 * @interface Command
 */
export interface Command {
    /**
     * All the aliases that were registered for this command
     * @type {Array<string>}
     * @memberof Command
     */
    aliases: Array<string>;
    /**
     * The description provided with the command
     * @type {string}
     * @memberof Command
     */
    description: string;
    /**
     * Extended help information on the usage of the command
     * @type {string}
     * @memberof Command
     */
    help: string;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof Command
     */
    link: string;
    /**
     * The name of the command, sometimes also referred to as primary alias.
     * @type {string}
     * @memberof Command
     */
    name: string;
    /**
     * A short description of the usage of this command
     * @type {string}
     * @memberof Command
     */
    usage: string;
}

/**
 * 
 * @export
 * @interface CommandCall
 */
export interface CommandCall {
    /**
     * The arguments that were passed to the command
     * @type {string}
     * @memberof CommandCall
     */
    args: string;
    /**
     * True if the command was cancelled, false otherwise
     * @type {boolean}
     * @memberof CommandCall
     */
    cancelled: boolean;
    /**
     * The cause of the command execution
     * @type {Cause}
     * @memberof CommandCall
     */
    cause: Cause;
    /**
     * The command that was executed (without arguments)
     * @type {string}
     * @memberof CommandCall
     */
    command: string;
    /**
     * The result of the command execution
     * @type {CommandResult}
     * @memberof CommandCall
     */
    result: CommandResult;
    /**
     * The timestamp at which the command was executed (epoch millis)
     * @type {number}
     * @memberof CommandCall
     */
    timestamp: number;
}

/**
 * 
 * @export
 * @interface CommandData
 */
export interface CommandData {
    /**
     * True if the output is tracked, false otherwise
     * @type {boolean}
     * @memberof CommandData
     */
    tracksOutput: boolean;
    /**
     * The last output produced
     * @type {string}
     * @memberof CommandData
     */
    lastOutput?: string;
    /**
     * The stored command
     * @type {string}
     * @memberof CommandData
     */
    storedCommand: string;
    /**
     * The amount of successfull executions
     * @type {number}
     * @memberof CommandData
     */
    successCount: number;
}

/**
 * 
 * @export
 * @interface CommandResult
 */
export interface CommandResult {
    /**
     * The number of blocks that were affected by this command
     * @type {number}
     * @memberof CommandResult
     */
    affectedBlocks?: number;
    /**
     * The number of entities that were affected by this command
     * @type {number}
     * @memberof CommandResult
     */
    affectedEntities?: number;
    /**
     * The number of items that were affected by this command
     * @type {number}
     * @memberof CommandResult
     */
    affectedItems?: number;
    /**
     * The results of the query
     * @type {number}
     * @memberof CommandResult
     */
    queryResult?: number;
    /**
     * The success count
     * @type {number}
     * @memberof CommandResult
     */
    successCount?: number;
}

/**
 * 
 * @export
 * @interface CommandTask
 */
export interface CommandTask {
    /**
     * The list of commands that are executed
     * @type {Array<string>}
     * @memberof CommandTask
     */
    commands?: Array<string>;
    /**
     * The name of this task
     * @type {string}
     * @memberof CommandTask
     */
    name?: string;
    /**
     * The command that is executed
     * @type {Schedule}
     * @memberof CommandTask
     */
    schedule?: Schedule;
}

/**
 * 
 * @export
 * @interface CreateBlockOperationRequest
 */
export interface CreateBlockOperationRequest {
    /**
     * The maximum world coordinates spanning the cube where the operation is run
     * @type {Vector3i}
     * @memberof CreateBlockOperationRequest
     */
    max: Vector3i;
    /**
     * The minimum world coordinates spanning the cube where the operation is run
     * @type {Vector3i}
     * @memberof CreateBlockOperationRequest
     */
    min: Vector3i;
    /**
     * The type of the block operation
     * @type {string}
     * @memberof CreateBlockOperationRequest
     */
    type: CreateBlockOperationRequest.TypeEnum;
    /**
     * The world that the operation is run in
     * @type {string}
     * @memberof CreateBlockOperationRequest
     */
    world: string;
    /**
     * The block that we want to change all other blocks into (when using an UPDATE operation
     * @type {BlockState}
     * @memberof CreateBlockOperationRequest
     */
    block?: BlockState;
    /**
     * An array of blocks defining what each block in the spanned cube
     * @type {Array<Array<Array<BlockState>>>}
     * @memberof CreateBlockOperationRequest
     */
    blocks?: Array<Array<Array<BlockState>>>;
}

/**
 * @export
 * @namespace CreateBlockOperationRequest
 */
export namespace CreateBlockOperationRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GET = <any> 'GET',
        CHANGE = <any> 'CHANGE'
    }
}

/**
 * 
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
    /**
     * The position where the entity is spawned
     * @type {Vector3d}
     * @memberof CreateEntityRequest
     */
    position: Vector3d;
    /**
     * The type of entity that will be spawned
     * @type {string}
     * @memberof CreateEntityRequest
     */
    type: string;
    /**
     * The world that the entity will be spawned in
     * @type {string}
     * @memberof CreateEntityRequest
     */
    world: string;
}

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * The password of the user
     * @type {string}
     * @memberof CreateUserRequest
     */
    password: string;
    /**
     * The username of the user
     * @type {string}
     * @memberof CreateUserRequest
     */
    username: string;
}

/**
 * 
 * @export
 * @interface CreateWorldRequest
 */
export interface CreateWorldRequest {
    /**
     * The name of the world
     * @type {string}
     * @memberof CreateWorldRequest
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorldRequest
     */
    allowCommands?: boolean;
    /**
     * Which difficulty the world is set to
     * @type {CatalogType}
     * @memberof CreateWorldRequest
     */
    difficulty?: CatalogType;
    /**
     * The the dimension that this world belongs to
     * @type {string}
     * @memberof CreateWorldRequest
     */
    dimension?: string;
    /**
     * Which game mode the world defaults to
     * @type {GameMode}
     * @memberof CreateWorldRequest
     */
    gameMode?: GameMode;
    /**
     * Which generator to use for the world
     * @type {CatalogType}
     * @memberof CreateWorldRequest
     */
    generator?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorldRequest
     */
    keepSpawnLoaded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorldRequest
     */
    loadOnStartup?: boolean;
    /**
     * The seed of the world
     * @type {number}
     * @memberof CreateWorldRequest
     */
    seed?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorldRequest
     */
    usesMapFeatures?: boolean;
}

/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    defaultFractionDigits?: number;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    pluralDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    symbol?: string;
}

/**
 * 
 * @export
 * @interface DamageRequest
 */
export interface DamageRequest {
    /**
     * The amount of damage that should be dealt to the entity
     * @type {number}
     * @memberof DamageRequest
     */
    amount?: number;
    /**
     * The type of damage that should be dealt
     * @type {string}
     * @memberof DamageRequest
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface DamageableData
 */
export interface DamageableData {
    /**
     * The entity which last attacked this entity
     * @type {EntitySnapshot}
     * @memberof DamageableData
     */
    lastAttacker?: EntitySnapshot;
    /**
     * The amount of damage inflicted by the last attacker
     * @type {number}
     * @memberof DamageableData
     */
    lastDamage?: number;
}

/**
 * 
 * @export
 * @interface DespawnDelayData
 */
export interface DespawnDelayData {
    /**
     * The amount of time until this entity despawns
     * @type {number}
     * @memberof DespawnDelayData
     */
    delay: number;
    /**
     * True if this entity never despawns, false otherwise
     * @type {boolean}
     * @memberof DespawnDelayData
     */
    infinite: boolean;
}

/**
 * 
 * @export
 * @interface DurabilityData
 */
export interface DurabilityData {
    /**
     * True if this entity is unbreakable, false otherwise
     * @type {boolean}
     * @memberof DurabilityData
     */
    unbreakable: boolean;
    /**
     * The remaining durability of this entity
     * @type {number}
     * @memberof DurabilityData
     */
    durability: number;
}

/**
 * 
 * @export
 * @interface DyeColor
 */
export interface DyeColor {
    /**
     * The unique id of this dye color
     * @type {string}
     * @memberof DyeColor
     */
    id: string;
    /**
     * The name of this dye color
     * @type {string}
     * @memberof DyeColor
     */
    name: string;
    /**
     * The color represented by this dye color
     * @type {Color}
     * @memberof DyeColor
     */
    color: Color;
}

/**
 * 
 * @export
 * @interface Enchantment
 */
export interface Enchantment {
    /**
     * The name of the enchantment type
     * @type {string}
     * @memberof Enchantment
     */
    name?: string;
    /**
     * The unique id of the enchantment type
     * @type {string}
     * @memberof Enchantment
     */
    id?: string;
    /**
     * The level of the enchantment
     * @type {number}
     * @memberof Enchantment
     */
    level?: number;
}

/**
 * 
 * @export
 * @interface EndGatewayData
 */
export interface EndGatewayData {
    /**
     * The age of this gateway
     * @type {number}
     * @memberof EndGatewayData
     */
    age: number;
    /**
     * True if this is an exact teleport, false otherwise
     * @type {boolean}
     * @memberof EndGatewayData
     */
    exactTeleport: boolean;
    /**
     * The exit position in the nether
     * @type {Vector3i}
     * @memberof EndGatewayData
     */
    exitPosition: Vector3i;
    /**
     * The cooldown of the teleport
     * @type {number}
     * @memberof EndGatewayData
     */
    teleportCooldown: number;
}

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof Entity
     */
    link: string;
    /**
     * The current location of the entity
     * @type {Location}
     * @memberof Entity
     */
    location: Location;
    /**
     * The current rotation of the entity
     * @type {Vector3d}
     * @memberof Entity
     */
    rotation: Vector3d;
    /**
     * The current scale of the entity
     * @type {Vector3d}
     * @memberof Entity
     */
    scale: Vector3d;
    /**
     * The type of entity
     * @type {CatalogType}
     * @memberof Entity
     */
    type: CatalogType;
    /**
     * The unique UUID of the entity
     * @type {string}
     * @memberof Entity
     */
    uuid: string;
    /**
     * The current velocity of the entity
     * @type {Vector3d}
     * @memberof Entity
     */
    velocity: Vector3d;
    /**
     * 
     * @type {Inventory}
     * @memberof Entity
     */
    inventory?: Inventory;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof Entity
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof Entity
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    axis?: Entity.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof Entity
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof Entity
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof Entity
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof Entity
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof Entity
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof Entity
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof Entity
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof Entity
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    connectedDirection?: Array<Entity.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof Entity
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof Entity
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    direction?: Entity.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof Entity
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof Entity
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Entity
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof Entity
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof Entity
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof Entity
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof Entity
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof Entity
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof Entity
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof Entity
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof Entity
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof Entity
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof Entity
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof Entity
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof Entity
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof Entity
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof Entity
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof Entity
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof Entity
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    inWall?: boolean;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof Entity
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof Entity
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof Entity
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof Entity
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof Entity
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof Entity
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof Entity
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof Entity
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Entity
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof Entity
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof Entity
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof Entity
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof Entity
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Entity
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof Entity
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof Entity
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof Entity
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof Entity
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof Entity
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof Entity
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof Entity
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Entity
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof Entity
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof Entity
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof Entity
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof Entity
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof Entity
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof Entity
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof Entity
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof Entity
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    matter?: Entity.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof Entity
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof Entity
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof Entity
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Entity
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Entity
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace Entity
 */
export namespace Entity {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface EntityArchtype
 */
export interface EntityArchtype {
    /**
     * The entity type represented by this archtype
     * @type {CatalogType}
     * @memberof EntityArchtype
     */
    type: CatalogType;
}

/**
 * 
 * @export
 * @interface EntitySnapshot
 */
export interface EntitySnapshot {
    /**
     * The uuid of the entity
     * @type {string}
     * @memberof EntitySnapshot
     */
    uuid?: string;
    /**
     * The type of the entity
     * @type {CatalogType}
     * @memberof EntitySnapshot
     */
    type?: CatalogType;
    /**
     * The transform of the entity
     * @type {Transform}
     * @memberof EntitySnapshot
     */
    transform?: Transform;
}

/**
 * 
 * @export
 * @interface EquipmentSlotType
 */
export interface EquipmentSlotType {
    /**
     * 
     * @type {string}
     * @memberof EquipmentSlotType
     */
    operator?: EquipmentSlotType.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof EquipmentSlotType
     */
    key?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof EquipmentSlotType
     */
    value?: CatalogType;
}

/**
 * @export
 * @namespace EquipmentSlotType
 */
export namespace EquipmentSlotType {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface ExecuteCommandRequest
 */
export interface ExecuteCommandRequest {
    /**
     * The command to execute
     * @type {string}
     * @memberof ExecuteCommandRequest
     */
    command: string;
    /**
     * True to hide the execution of the command in the console, false otherwise
     * @type {boolean}
     * @memberof ExecuteCommandRequest
     */
    hiddenInConsole?: boolean;
    /**
     * The name of the source that executes the command
     * @type {string}
     * @memberof ExecuteCommandRequest
     */
    name?: string;
    /**
     * The amount of text lines to wait for in the response
     * @type {number}
     * @memberof ExecuteCommandRequest
     */
    waitLines?: number;
    /**
     * The amount of time to wait for a response
     * @type {number}
     * @memberof ExecuteCommandRequest
     */
    waitTime?: number;
}

/**
 * 
 * @export
 * @interface ExecuteCommandResponse
 */
export interface ExecuteCommandResponse {
    /**
     * The command that was executed
     * @type {string}
     * @memberof ExecuteCommandResponse
     */
    cmd: string;
    /**
     * True if this command executed successfully, false otherwise
     * @type {boolean}
     * @memberof ExecuteCommandResponse
     */
    ok: boolean;
    /**
     * Any potential error that occured during execution
     * @type {string}
     * @memberof ExecuteCommandResponse
     */
    error?: string;
    /**
     * The response chat lines that were sent when executing the command
     * @type {Array<string>}
     * @memberof ExecuteCommandResponse
     */
    response?: Array<string>;
}

/**
 * 
 * @export
 * @interface ExecuteMethodParam
 */
export interface ExecuteMethodParam {
    /**
     * The type of the parameter
     * @type {string}
     * @memberof ExecuteMethodParam
     */
    type: ExecuteMethodParam.TypeEnum;
    /**
     * The value of the parameter
     * @type {string}
     * @memberof ExecuteMethodParam
     */
    value: string;
}

/**
 * @export
 * @namespace ExecuteMethodParam
 */
export namespace ExecuteMethodParam {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INT = <any> 'INT',
        INTEGER = <any> 'INTEGER',
        FLOAT = <any> 'FLOAT',
        DOUBLE = <any> 'DOUBLE',
        BOOL = <any> 'BOOL',
        BOOLEAN = <any> 'BOOLEAN',
        BYTE = <any> 'BYTE',
        CHAR = <any> 'CHAR',
        LONG = <any> 'LONG',
        SHORT = <any> 'SHORT',
        STRING = <any> 'STRING',
        CLASS = <any> 'CLASS',
        ENUM = <any> 'ENUM',
        VECTOR3D = <any> 'VECTOR3D',
        VECTOR3I = <any> 'VECTOR3I',
        TEXT = <any> 'TEXT',
        WORLD = <any> 'WORLD',
        PLAYER = <any> 'PLAYER',
        ITEMSTACK = <any> 'ITEMSTACK',
        STATIC = <any> 'STATIC'
    }
}

/**
 * 
 * @export
 * @interface ExecuteMethodRequest
 */
export interface ExecuteMethodRequest {
    /**
     * The method that is executed
     * @type {string}
     * @memberof ExecuteMethodRequest
     */
    method: string;
    /**
     * The parameters of the method (if applicable)
     * @type {Array<ExecuteMethodParam>}
     * @memberof ExecuteMethodRequest
     */
    parameters?: Array<ExecuteMethodParam>;
}

/**
 * 
 * @export
 * @interface ExecuteMethodResponse
 */
export interface ExecuteMethodResponse {
    /**
     * 
     * @type {CachedObject}
     * @memberof ExecuteMethodResponse
     */
    object?: CachedObject;
    /**
     * 
     * @type {any}
     * @memberof ExecuteMethodResponse
     */
    result?: any;
}

/**
 * 
 * @export
 * @interface ExperienceHolderData
 */
export interface ExperienceHolderData {
    /**
     * The current level of the entity
     * @type {number}
     * @memberof ExperienceHolderData
     */
    level?: number;
    /**
     * The experience gained since the last level
     * @type {number}
     * @memberof ExperienceHolderData
     */
    experience?: number;
    /**
     * The total amount of experience collected
     * @type {number}
     * @memberof ExperienceHolderData
     */
    totalExperience?: number;
}

/**
 * 
 * @export
 * @interface FallingBlockData
 */
export interface FallingBlockData {
    /**
     * The state of the falling block
     * @type {BlockState}
     * @memberof FallingBlockData
     */
    state: BlockState;
    /**
     * True if the block can drop as an item, false otherwise
     * @type {boolean}
     * @memberof FallingBlockData
     */
    canDropAsItem: boolean;
    /**
     * True if the block can hurt entities, false otherwise
     * @type {boolean}
     * @memberof FallingBlockData
     */
    canHurtEntities: boolean;
    /**
     * True if this falling block can be placed as a normal block, false otherwise
     * @type {boolean}
     * @memberof FallingBlockData
     */
    canPlaceAsBlock: boolean;
    /**
     * The amount of damage per block this falling block deals
     * @type {number}
     * @memberof FallingBlockData
     */
    fallDamagePerBlock: number;
    /**
     * The amount of time (in ticks) this block has been falling for
     * @type {number}
     * @memberof FallingBlockData
     */
    fallTime: number;
    /**
     * The maximum amount of damage this block can deal
     * @type {number}
     * @memberof FallingBlockData
     */
    maxFallDamage: number;
}

/**
 * 
 * @export
 * @interface FireworkEffect
 */
export interface FireworkEffect {
    /**
     * The shape of the firework
     * @type {CatalogType}
     * @memberof FireworkEffect
     */
    shape: CatalogType;
    /**
     * True if the firework flickers, false otherwise
     * @type {boolean}
     * @memberof FireworkEffect
     */
    flickers: boolean;
    /**
     * The colors that make up this firework
     * @type {Array<Color>}
     * @memberof FireworkEffect
     */
    colors: Array<Color>;
    /**
     * The fade colors that this firework has
     * @type {Array<Color>}
     * @memberof FireworkEffect
     */
    fadeColors: Array<Color>;
    /**
     * True if this firework has a trail, false otherwise
     * @type {boolean}
     * @memberof FireworkEffect
     */
    trail: boolean;
}

/**
 * 
 * @export
 * @interface FireworkRocketData
 */
export interface FireworkRocketData {
    /**
     * The flight modifier of this firework rocket
     * @type {number}
     * @memberof FireworkRocketData
     */
    flightModifier: number;
}

/**
 * 
 * @export
 * @interface FluidStack
 */
export interface FluidStack {
    /**
     * The type of fluid contained within this stack
     * @type {CatalogType}
     * @memberof FluidStack
     */
    type: CatalogType;
    /**
     * The amount of fluid in this stack
     * @type {number}
     * @memberof FluidStack
     */
    volume: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof FluidStack
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof FluidStack
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    axis?: FluidStack.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof FluidStack
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof FluidStack
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof FluidStack
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof FluidStack
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof FluidStack
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof FluidStack
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof FluidStack
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof FluidStack
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof FluidStack
     */
    connectedDirection?: Array<FluidStack.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof FluidStack
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof FluidStack
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    direction?: FluidStack.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof FluidStack
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof FluidStack
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof FluidStack
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof FluidStack
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof FluidStack
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof FluidStack
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof FluidStack
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof FluidStack
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof FluidStack
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof FluidStack
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof FluidStack
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof FluidStack
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof FluidStack
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof FluidStack
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof FluidStack
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof FluidStack
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof FluidStack
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof FluidStack
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof FluidStack
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    inWall?: boolean;
    /**
     * 
     * @type {Inventory}
     * @memberof FluidStack
     */
    inventory?: Inventory;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof FluidStack
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof FluidStack
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof FluidStack
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof FluidStack
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof FluidStack
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof FluidStack
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof FluidStack
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof FluidStack
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FluidStack
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof FluidStack
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof FluidStack
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof FluidStack
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof FluidStack
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof FluidStack
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof FluidStack
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof FluidStack
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof FluidStack
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof FluidStack
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof FluidStack
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof FluidStack
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof FluidStack
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof FluidStack
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof FluidStack
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof FluidStack
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof FluidStack
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof FluidStack
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof FluidStack
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof FluidStack
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof FluidStack
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof FluidStack
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof FluidStack
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof FluidStack
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof FluidStack
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof FluidStack
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof FluidStack
     */
    matter?: FluidStack.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof FluidStack
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof FluidStack
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof FluidStack
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof FluidStack
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof FluidStack
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FluidStack
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace FluidStack
 */
export namespace FluidStack {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface FoodData
 */
export interface FoodData {
    /**
     * The food level of this entity
     * @type {number}
     * @memberof FoodData
     */
    foodLevel: number;
    /**
     * The saturation of this entity
     * @type {number}
     * @memberof FoodData
     */
    saturation: number;
    /**
     * The exhaustion of this entity
     * @type {number}
     * @memberof FoodData
     */
    exhaustion: number;
}

/**
 * 
 * @export
 * @interface FurnaceData
 */
export interface FurnaceData {
    /**
     * The maximum amount of time (in ticks) the current fuel item lasts
     * @type {number}
     * @memberof FurnaceData
     */
    maxBurnTime: number;
    /**
     * The total amount of time (in ticks) the stack has to cook for to be done
     * @type {number}
     * @memberof FurnaceData
     */
    maxCookTime: number;
    /**
     * The amount of time (in ticks) that has passed since this fuel item started burning
     * @type {number}
     * @memberof FurnaceData
     */
    passedBurnTime: number;
    /**
     * The amount of time (in ticks) that has passed since the item stack started cooking
     * @type {number}
     * @memberof FurnaceData
     */
    passedCookTime: number;
}

/**
 * 
 * @export
 * @interface FuseData
 */
export interface FuseData {
    /**
     * The total amount of time (in ticks) the fuse burns for
     * @type {number}
     * @memberof FuseData
     */
    fuseDuration: number;
    /**
     * The amount of ticks remaining on this fuse
     * @type {number}
     * @memberof FuseData
     */
    ticksRemaining: number;
}

/**
 * 
 * @export
 * @interface GameMode
 */
export interface GameMode {
    /**
     * The unique id of the game mode
     * @type {string}
     * @memberof GameMode
     */
    id: string;
    /**
     * The name of the game mode
     * @type {string}
     * @memberof GameMode
     */
    name: string;
}

/**
 * 
 * @export
 * @interface GrowthData
 */
export interface GrowthData {
    /**
     * The current growth stage of this entity
     * @type {number}
     * @memberof GrowthData
     */
    stage: number;
}

/**
 * 
 * @export
 * @interface GuiIdProperty
 */
export interface GuiIdProperty {
    /**
     * 
     * @type {string}
     * @memberof GuiIdProperty
     */
    operator?: GuiIdProperty.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof GuiIdProperty
     */
    key?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof GuiIdProperty
     */
    value?: CatalogType;
}

/**
 * @export
 * @namespace GuiIdProperty
 */
export namespace GuiIdProperty {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface HealthData
 */
export interface HealthData {
    /**
     * The current health of the entity
     * @type {number}
     * @memberof HealthData
     */
    current: number;
    /**
     * The maximum health of the entity
     * @type {number}
     * @memberof HealthData
     */
    max: number;
}

/**
 * 
 * @export
 * @interface HideData
 */
export interface HideData {
    /**
     * Gets the 'attributes hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideAttributes?: boolean;
    /**
     * Gets the 'can destory hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideCanDestroy?: boolean;
    /**
     * Gets the 'can place hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideCanPlace?: boolean;
    /**
     * Gets the 'enchantments hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideEnchantments?: boolean;
    /**
     * Gets the 'miscellaneous hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideMiscellaneous?: boolean;
    /**
     * Gets the 'unbreakable hidden' state of the item stack
     * @type {boolean}
     * @memberof HideData
     */
    hideUnbreakable?: boolean;
}

/**
 * 
 * @export
 * @interface HorseData
 */
export interface HorseData {
    /**
     * The color of the horse
     * @type {CatalogType}
     * @memberof HorseData
     */
    color: CatalogType;
    /**
     * The style of the horse
     * @type {CatalogType}
     * @memberof HorseData
     */
    style: CatalogType;
}

/**
 * 
 * @export
 * @interface Identifiable
 */
export interface Identifiable {
    /**
     * 
     * @type {string}
     * @memberof Identifiable
     */
    operator?: Identifiable.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof Identifiable
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof Identifiable
     */
    value?: string;
}

/**
 * @export
 * @namespace Identifiable
 */
export namespace Identifiable {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface IgniteableData
 */
export interface IgniteableData {
    /**
     * The delay of the fire
     * @type {number}
     * @memberof IgniteableData
     */
    fireDelay: number;
    /**
     * The amount of ticks the fire will burn for
     * @type {number}
     * @memberof IgniteableData
     */
    fireTicks: number;
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse400
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse400
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse401
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse403
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse403
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse404
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse500
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse500
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse501
 */
export interface InlineResponse501 {
    /**
     * The error message describing the error
     * @type {string}
     * @memberof InlineResponse501
     */
    error?: string;
    /**
     * The status code of the error (also provided in the HTTP header)
     * @type {number}
     * @memberof InlineResponse501
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface InteractiveMessage
 */
export interface InteractiveMessage {
    /**
     * The id of the message. Used to identify responses.
     * @type {string}
     * @memberof InteractiveMessage
     */
    id: string;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof InteractiveMessage
     */
    link: string;
    /**
     * The target of the message, usually this is a player UUID. Can be set to \"server\" to send to all online players.
     * @type {string}
     * @memberof InteractiveMessage
     */
    target: string;
    /**
     * The unique UUID of this message
     * @type {string}
     * @memberof InteractiveMessage
     */
    uuid: string;
    /**
     * The actual content of the message
     * @type {string}
     * @memberof InteractiveMessage
     */
    message?: string;
    /**
     * True if this message can only be replied to once per target, false otherwise
     * @type {boolean}
     * @memberof InteractiveMessage
     */
    once?: boolean;
    /**
     * Clickable options that the player can select from
     * @type {Array<InteractiveMessageOption>}
     * @memberof InteractiveMessage
     */
    options?: Array<InteractiveMessageOption>;
    /**
     * A list of targets that will receive the message. Usually a list of player UUIDs
     * @type {Array<string>}
     * @memberof InteractiveMessage
     */
    targets?: Array<string>;
}

/**
 * 
 * @export
 * @interface InteractiveMessageOption
 */
export interface InteractiveMessageOption {
    /**
     * The key of the option (this is sent to the WebHook)
     * @type {string}
     * @memberof InteractiveMessageOption
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof InteractiveMessageOption
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface Inventory
 */
export interface Inventory {
    /**
     * The maximum capacity of the inventory (maximum number of stacks)
     * @type {number}
     * @memberof Inventory
     */
    capacity: number;
    /**
     * The name of the inventory
     * @type {string}
     * @memberof Inventory
     */
    name: string;
    /**
     * Gets a list of slots in the inventory (with their items)
     * @type {Array<Slot>}
     * @memberof Inventory
     */
    slots: Array<Slot>;
    /**
     * The total amount of items currently in the inventory
     * @type {number}
     * @memberof Inventory
     */
    totalItems: number;
    /**
     * The type of the inventory
     * @type {CatalogTypeInventoryArchetype}
     * @memberof Inventory
     */
    type: CatalogTypeInventoryArchetype;
}

/**
 * 
 * @export
 * @interface InventoryCapacity
 */
export interface InventoryCapacity {
    /**
     * 
     * @type {string}
     * @memberof InventoryCapacity
     */
    operator?: InventoryCapacity.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof InventoryCapacity
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof InventoryCapacity
     */
    value?: number;
}

/**
 * @export
 * @namespace InventoryCapacity
 */
export namespace InventoryCapacity {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface InventoryDimension
 */
export interface InventoryDimension {
    /**
     * 
     * @type {string}
     * @memberof InventoryDimension
     */
    operator?: InventoryDimension.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof InventoryDimension
     */
    key?: string;
    /**
     * 
     * @type {Vector2i}
     * @memberof InventoryDimension
     */
    value?: Vector2i;
    /**
     * 
     * @type {number}
     * @memberof InventoryDimension
     */
    rows?: number;
    /**
     * 
     * @type {number}
     * @memberof InventoryDimension
     */
    columns?: number;
}

/**
 * @export
 * @namespace InventoryDimension
 */
export namespace InventoryDimension {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface InventoryTitle
 */
export interface InventoryTitle {
    /**
     * 
     * @type {string}
     * @memberof InventoryTitle
     */
    operator?: InventoryTitle.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof InventoryTitle
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryTitle
     */
    value?: string;
}

/**
 * @export
 * @namespace InventoryTitle
 */
export namespace InventoryTitle {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface InvisibilityData
 */
export interface InvisibilityData {
    /**
     * True if this entity ignores collisions, false otherwise
     * @type {boolean}
     * @memberof InvisibilityData
     */
    ignoreCollision: boolean;
    /**
     * True if this entity is invisible, false otherwise
     * @type {boolean}
     * @memberof InvisibilityData
     */
    invisible: boolean;
    /**
     * True if this entity is not targetable, false otherwise
     * @type {boolean}
     * @memberof InvisibilityData
     */
    untargetable: boolean;
    /**
     * True if this entity is vanished, false otherwise
     * @type {boolean}
     * @memberof InvisibilityData
     */
    vanish: boolean;
}

/**
 * 
 * @export
 * @interface InvulnerabilityData
 */
export interface InvulnerabilityData {
    /**
     * The amount of ticks this entity will remain invulnerable for
     * @type {number}
     * @memberof InvulnerabilityData
     */
    ticks: number;
}

/**
 * 
 * @export
 * @interface ItemStack
 */
export interface ItemStack {
    /**
     * The quantity of items in this stack
     * @type {number}
     * @memberof ItemStack
     */
    quantity: number;
    /**
     * The type of this item
     * @type {CatalogType}
     * @memberof ItemStack
     */
    type: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof ItemStack
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof ItemStack
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    axis?: ItemStack.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof ItemStack
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof ItemStack
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof ItemStack
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof ItemStack
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof ItemStack
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof ItemStack
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof ItemStack
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof ItemStack
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemStack
     */
    connectedDirection?: Array<ItemStack.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof ItemStack
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof ItemStack
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    direction?: ItemStack.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof ItemStack
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof ItemStack
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof ItemStack
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof ItemStack
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof ItemStack
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof ItemStack
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof ItemStack
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof ItemStack
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof ItemStack
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof ItemStack
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof ItemStack
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof ItemStack
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof ItemStack
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof ItemStack
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof ItemStack
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof ItemStack
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof ItemStack
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof ItemStack
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof ItemStack
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    inWall?: boolean;
    /**
     * 
     * @type {Inventory}
     * @memberof ItemStack
     */
    inventory?: Inventory;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof ItemStack
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof ItemStack
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof ItemStack
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof ItemStack
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemStack
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof ItemStack
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof ItemStack
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemStack
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemStack
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof ItemStack
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof ItemStack
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof ItemStack
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof ItemStack
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof ItemStack
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemStack
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof ItemStack
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof ItemStack
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof ItemStack
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof ItemStack
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof ItemStack
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof ItemStack
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof ItemStack
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof ItemStack
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof ItemStack
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof ItemStack
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof ItemStack
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof ItemStack
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof ItemStack
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof ItemStack
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof ItemStack
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof ItemStack
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof ItemStack
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof ItemStack
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof ItemStack
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemStack
     */
    matter?: ItemStack.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof ItemStack
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof ItemStack
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof ItemStack
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof ItemStack
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof ItemStack
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemStack
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace ItemStack
 */
export namespace ItemStack {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface JoinData
 */
export interface JoinData {
    /**
     * The first time this entity joined the server
     * @type {number}
     * @memberof JoinData
     */
    first: number;
    /**
     * The most recent time this entity joined the server
     * @type {number}
     * @memberof JoinData
     */
    last: number;
}

/**
 * 
 * @export
 * @interface LeashData
 */
export interface LeashData {
    /**
     * The holder of this entity's leash
     * @type {Entity}
     * @memberof LeashData
     */
    holder: Entity;
}

/**
 * 
 * @export
 * @interface LocalDate
 */
export interface LocalDate {
    /**
     * The day of the month (1-31)
     * @type {number}
     * @memberof LocalDate
     */
    day?: number;
    /**
     * The month in the year (1-12)
     * @type {number}
     * @memberof LocalDate
     */
    month?: number;
    /**
     * The year
     * @type {number}
     * @memberof LocalDate
     */
    year?: number;
}

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The position within the world that this location refers to
     * @type {Vector3d}
     * @memberof Location
     */
    position: Vector3d;
    /**
     * The world this location refers to
     * @type {World}
     * @memberof Location
     */
    world: World;
}

/**
 * 
 * @export
 * @interface MMCRestrictItem
 */
export interface MMCRestrictItem {
    /**
     * The reason why the item is banned
     * @type {string}
     * @memberof MMCRestrictItem
     */
    banReason: string;
    /**
     * True if breaking of this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    breakingBanned: boolean;
    /**
     * True if crafting this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    craftBanned: boolean;
    /**
     * True if dropping this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    dropBanned: boolean;
    /**
     * True if this item shows up in the public restricted items list, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    hidden: boolean;
    /**
     * The item type that is banned
     * @type {CatalogTypeItemType}
     * @memberof MMCRestrictItem
     */
    item: CatalogTypeItemType;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof MMCRestrictItem
     */
    link: string;
    /**
     * True if ownership of this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    ownershipBanned: boolean;
    /**
     * True if the placing of this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    placingBanned: boolean;
    /**
     * True if the usage of this item is banned, false otherwise
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    usageBanned: boolean;
    /**
     * True if this item is banned from the world, false otherwise?
     * @type {boolean}
     * @memberof MMCRestrictItem
     */
    worldBanned: boolean;
}

/**
 * 
 * @export
 * @interface MMCTicketsTicket
 */
export interface MMCTicketsTicket {
    /**
     * The unique id of this ticket
     * @type {number}
     * @memberof MMCTicketsTicket
     */
    id: number;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof MMCTicketsTicket
     */
    link: string;
    /**
     * The message sent along with this ticket
     * @type {string}
     * @memberof MMCTicketsTicket
     */
    message: string;
    /**
     * The current status of the ticket
     * @type {string}
     * @memberof MMCTicketsTicket
     */
    status: MMCTicketsTicket.StatusEnum;
    /**
     * The unix timestamp (in seconds) when this ticket was submitted
     * @type {number}
     * @memberof MMCTicketsTicket
     */
    timestamp: number;
    /**
     * The comment added by staff to this ticket
     * @type {string}
     * @memberof MMCTicketsTicket
     */
    comment?: string;
    /**
     * The location at which this ticket was submitted
     * @type {Location}
     * @memberof MMCTicketsTicket
     */
    location?: Location;
    /**
     * True if staff has been notified about this ticket, false otherwise
     * @type {number}
     * @memberof MMCTicketsTicket
     */
    notified?: number;
    /**
     * The sender of this ticket
     * @type {Player}
     * @memberof MMCTicketsTicket
     */
    sender?: Player;
    /**
     * The staff member that was assigned to this ticket
     * @type {Player}
     * @memberof MMCTicketsTicket
     */
    staff?: Player;
}

/**
 * @export
 * @namespace MMCTicketsTicket
 */
export namespace MMCTicketsTicket {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Open = <any> 'Open',
        Claimed = <any> 'Claimed',
        Held = <any> 'Held',
        Closed = <any> 'Closed'
    }
}

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The content of the message
     * @type {string}
     * @memberof Message
     */
    content: string;
    /**
     * The receivers of this message
     * @type {Array<any>}
     * @memberof Message
     */
    receivers: Array<any>;
    /**
     * The timestamp at which the chat message was sent (epoch millis)
     * @type {number}
     * @memberof Message
     */
    timestamp: number;
}

/**
 * 
 * @export
 * @interface MinecartBlockData
 */
export interface MinecartBlockData {
    /**
     * The current state of the block
     * @type {BlockState}
     * @memberof MinecartBlockData
     */
    state: BlockState;
    /**
     * The offset of the block
     * @type {number}
     * @memberof MinecartBlockData
     */
    offset: number;
}

/**
 * 
 * @export
 * @interface MobSpawnerData
 */
export interface MobSpawnerData {
    /**
     * The maximum number of nearby entities for another mob to spawn
     * @type {number}
     * @memberof MobSpawnerData
     */
    maximumNearbyEntities: number;
    /**
     * The maximum delay between two consecutive spawns
     * @type {number}
     * @memberof MobSpawnerData
     */
    maximumSpawnDelay: number;
    /**
     * The minimum delay between two consecutive spawns
     * @type {number}
     * @memberof MobSpawnerData
     */
    minimumSpawnDelay: number;
    /**
     * The next entity type that will be spawned by this spawner
     * @type {EntityArchtype}
     * @memberof MobSpawnerData
     */
    nextEntityToSpawn: EntityArchtype;
    /**
     * A weighted table of probability for each entity type to spawn
     * @type {Array<TableEntryEntityArchetype>}
     * @memberof MobSpawnerData
     */
    possibleEntitiesToSpawn: Array<TableEntryEntityArchetype>;
    /**
     * The remaining time until the next spawn attempt
     * @type {number}
     * @memberof MobSpawnerData
     */
    remainingDelay: number;
    /**
     * The block range within there must be a player to trigger the spawn
     * @type {number}
     * @memberof MobSpawnerData
     */
    requiredPlayerRange: number;
    /**
     * The amount of entities that will spawn in one attempt
     * @type {number}
     * @memberof MobSpawnerData
     */
    spawnCount: number;
    /**
     * The range from the spawner within which the entities will spawn
     * @type {number}
     * @memberof MobSpawnerData
     */
    spawnRange: number;
}

/**
 * 
 * @export
 * @interface ModifyBlockOperationRequest
 */
export interface ModifyBlockOperationRequest {
    /**
     * True if the operation should be paused, false otherwise
     * @type {boolean}
     * @memberof ModifyBlockOperationRequest
     */
    paused?: boolean;
}

/**
 * 
 * @export
 * @interface ModifyUserRequest
 */
export interface ModifyUserRequest {
    /**
     * The permissions of the user
     * @type {any}
     * @memberof ModifyUserRequest
     */
    permissions?: any;
}

/**
 * 
 * @export
 * @interface NucleusKit
 */
export interface NucleusKit {
    /**
     * The commands that are executed when this kit is purchased/acquired by a player
     * @type {Array<string>}
     * @memberof NucleusKit
     */
    commands: Array<string>;
    /**
     * The cooldown (in seconds) this kit is on after buying it (per player)
     * @type {number}
     * @memberof NucleusKit
     */
    cooldown: number;
    /**
     * The cost to buy this kit
     * @type {number}
     * @memberof NucleusKit
     */
    cost: number;
    /**
     * True if this kit is awarded for joining the server the first time, false otherwise
     * @type {boolean}
     * @memberof NucleusKit
     */
    firstJoinKit: boolean;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof NucleusKit
     */
    link: string;
    /**
     * The unique name of this kit
     * @type {string}
     * @memberof NucleusKit
     */
    name: string;
    /**
     * True if this kit can only be purchased/acquired once, false otherwise
     * @type {boolean}
     * @memberof NucleusKit
     */
    oneTime: boolean;
    /**
     * The ItemStacks that are awarded to the player who buys/acquires this kit
     * @type {Array<ItemStack>}
     * @memberof NucleusKit
     */
    stacks: Array<ItemStack>;
}

/**
 * 
 * @export
 * @interface NucleusMailMessage
 */
export interface NucleusMailMessage {
    /**
     * The instant when the message was sent
     * @type {number}
     * @memberof NucleusMailMessage
     */
    date: number;
    /**
     * The message content
     * @type {string}
     * @memberof NucleusMailMessage
     */
    message: string;
    /**
     * The sender of the message
     * @type {Player}
     * @memberof NucleusMailMessage
     */
    sender?: Player;
}

/**
 * 
 * @export
 * @interface NucleusNamedLocation
 */
export interface NucleusNamedLocation {
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof NucleusNamedLocation
     */
    link: string;
    /**
     * The location of the jail
     * @type {Location}
     * @memberof NucleusNamedLocation
     */
    location: Location;
    /**
     * The unique name of this jail
     * @type {string}
     * @memberof NucleusNamedLocation
     */
    name: string;
    /**
     * The rotation of players within the jail
     * @type {Vector3d}
     * @memberof NucleusNamedLocation
     */
    rotation: Vector3d;
}

/**
 * 
 * @export
 * @interface PatternLayer
 */
export interface PatternLayer {
    /**
     * The base shape of this pattern
     * @type {CatalogType}
     * @memberof PatternLayer
     */
    shape: CatalogType;
    /**
     * The color of the pattern
     * @type {DyeColor}
     * @memberof PatternLayer
     */
    color: DyeColor;
}

/**
 * Represents a permissions struct that contains information to access the Web-API
 * @export
 * @interface PermissionStruct
 */
export interface PermissionStruct {
    /**
     * The key used authorize with the Web-API
     * @type {string}
     * @memberof PermissionStruct
     */
    key: string;
    /**
     * The human readable name of this permssions struct. Only useful for users.
     * @type {string}
     * @memberof PermissionStruct
     */
    name: string;
    /**
     * The permissions tree that this key grants access to
     * @type {any}
     * @memberof PermissionStruct
     */
    permissions: any;
    /**
     * The rate limit in requests per second that this key permits (0 = unlimited)
     * @type {number}
     * @memberof PermissionStruct
     */
    rateLimit: number;
}

/**
 * 
 * @export
 * @interface PickupDelayData
 */
export interface PickupDelayData {
    /**
     * The delay that entities must wait to pick up this entity
     * @type {number}
     * @memberof PickupDelayData
     */
    delay: number;
    /**
     * True if other entities can never pick up this entity, false otherwise
     * @type {boolean}
     * @memberof PickupDelayData
     */
    infinite: boolean;
}

/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * The player's IP address and port
     * @type {string}
     * @memberof Player
     */
    address: string;
    /**
     * 
     * @type {Inventory}
     * @memberof Player
     */
    inventory?: Inventory;
    /**
     * The latency (in milliseconds) of the player
     * @type {number}
     * @memberof Player
     */
    latency: number;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof Player
     */
    link: string;
    /**
     * The current Location of the player
     * @type {Location}
     * @memberof Player
     */
    location: Location;
    /**
     * The players name
     * @type {string}
     * @memberof Player
     */
    name: string;
    /**
     * True if the player is online, false otherwise
     * @type {boolean}
     * @memberof Player
     */
    online: boolean;
    /**
     * The current rotation of the player
     * @type {Vector3d}
     * @memberof Player
     */
    rotation: Vector3d;
    /**
     * The current scale of the player
     * @type {Vector3d}
     * @memberof Player
     */
    scale: Vector3d;
    /**
     * A list of all unlocked advancements of this player
     * @type {Array<Advancement>}
     * @memberof Player
     */
    unlockedAdvancements: Array<Advancement>;
    /**
     * The unique UUID of this player
     * @type {string}
     * @memberof Player
     */
    uuid: string;
    /**
     * The current velocity of the player
     * @type {Vector3d}
     * @memberof Player
     */
    velocity: Vector3d;
    /**
     * The item stack that the player is wearing as boots
     * @type {ItemStack}
     * @memberof Player
     */
    boots?: ItemStack;
    /**
     * The item stack that the player is wearing as chestplate
     * @type {ItemStack}
     * @memberof Player
     */
    chestplate?: ItemStack;
    /**
     * The item stack that the player is wearing as a helmet
     * @type {ItemStack}
     * @memberof Player
     */
    helmet?: ItemStack;
    /**
     * The item stack that the player is wearing as leggings
     * @type {ItemStack}
     * @memberof Player
     */
    leggings?: ItemStack;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof Player
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof Player
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    axis?: Player.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof Player
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof Player
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof Player
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof Player
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof Player
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof Player
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof Player
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof Player
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    connectedDirection?: Array<Player.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof Player
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof Player
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    direction?: Player.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof Player
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof Player
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Player
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof Player
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof Player
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof Player
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof Player
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof Player
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof Player
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof Player
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof Player
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof Player
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof Player
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof Player
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof Player
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof Player
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof Player
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof Player
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof Player
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    inWall?: boolean;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof Player
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof Player
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof Player
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof Player
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof Player
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof Player
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof Player
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof Player
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Player
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof Player
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof Player
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof Player
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof Player
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Player
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof Player
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof Player
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof Player
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof Player
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof Player
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof Player
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof Player
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Player
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof Player
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof Player
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof Player
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof Player
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof Player
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof Player
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof Player
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof Player
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    matter?: Player.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof Player
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof Player
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof Player
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Player
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace Player
 */
export namespace Player {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface PluginContainer
 */
export interface PluginContainer {
    /**
     * A list of authors that created this plugin
     * @type {Array<string>}
     * @memberof PluginContainer
     */
    authors: Array<string>;
    /**
     * Other plugins that this plugin depends on
     * @type {Array<PluginDependency>}
     * @memberof PluginContainer
     */
    dependencies: Array<PluginDependency>;
    /**
     * The unique id of this plugin
     * @type {string}
     * @memberof PluginContainer
     */
    id: string;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof PluginContainer
     */
    link: string;
    /**
     * The name of this plugin
     * @type {string}
     * @memberof PluginContainer
     */
    name: string;
    /**
     * The current loaded state of the plugin
     * @type {string}
     * @memberof PluginContainer
     */
    state: PluginContainer.StateEnum;
    /**
     * The type of the plugin
     * @type {string}
     * @memberof PluginContainer
     */
    type: PluginContainer.TypeEnum;
    /**
     * A description describing what this plugin does (hopefully)
     * @type {string}
     * @memberof PluginContainer
     */
    description?: string;
    /**
     * The file source where the plugin was loaded from.
     * @type {string}
     * @memberof PluginContainer
     */
    source?: string;
    /**
     * The url that was added to the plugin (probably the homepage)
     * @type {string}
     * @memberof PluginContainer
     */
    url?: string;
    /**
     * The current version of the plugin
     * @type {string}
     * @memberof PluginContainer
     */
    version?: string;
}

/**
 * @export
 * @namespace PluginContainer
 */
export namespace PluginContainer {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Loaded = <any> 'Loaded',
        Unloaded = <any> 'Unloaded',
        WillBeLoaded = <any> 'WillBeLoaded',
        WillBeUnloaded = <any> 'WillBeUnloaded'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Unknown = <any> 'Unknown',
        Sponge = <any> 'Sponge',
        Forge = <any> 'Forge',
        Minecraft = <any> 'Minecraft'
    }
}

/**
 * 
 * @export
 * @interface PluginDependency
 */
export interface PluginDependency {
    /**
     * The id of the plugin that the original plugin depends on
     * @type {string}
     * @memberof PluginDependency
     */
    id: string;
    /**
     * The load order of the original plugin in relation to the dependency
     * @type {string}
     * @memberof PluginDependency
     */
    loadOrder: PluginDependency.LoadOrderEnum;
    /**
     * True if this is an optional dependency, false otherwise
     * @type {boolean}
     * @memberof PluginDependency
     */
    optional: boolean;
    /**
     * The version of the plugin that the original plugin depends on
     * @type {string}
     * @memberof PluginDependency
     */
    version: string;
}

/**
 * @export
 * @namespace PluginDependency
 */
export namespace PluginDependency {
    /**
     * @export
     * @enum {string}
     */
    export enum LoadOrderEnum {
        NONE = <any> 'NONE',
        BEFORE = <any> 'BEFORE',
        AFTER = <any> 'AFTER'
    }
}

/**
 * 
 * @export
 * @interface PotionEffect
 */
export interface PotionEffect {
    /**
     * The type of effect this potion represents
     * @type {CatalogType}
     * @memberof PotionEffect
     */
    type: CatalogType;
    /**
     * The aplifier of this potion (I, II, III, IV, V, ...)
     * @type {number}
     * @memberof PotionEffect
     */
    amplifier: number;
    /**
     * The duration this potion lasts for
     * @type {number}
     * @memberof PotionEffect
     */
    duration: number;
}

/**
 * 
 * @export
 * @interface RedProtectRegion
 */
export interface RedProtectRegion {
    /**
     * The unique id of this region
     * @type {string}
     * @memberof RedProtectRegion
     */
    id: string;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof RedProtectRegion
     */
    link: string;
    /**
     * The maximum coordinates that define the region
     * @type {Vector3d}
     * @memberof RedProtectRegion
     */
    max: Vector3d;
    /**
     * The minimum coordinates that define the region
     * @type {Vector3d}
     * @memberof RedProtectRegion
     */
    min: Vector3d;
    /**
     * The name of this region
     * @type {string}
     * @memberof RedProtectRegion
     */
    name: string;
    /**
     * The world this region is located in
     * @type {World}
     * @memberof RedProtectRegion
     */
    world: World;
    /**
     * A list of players that are admins of this region
     * @type {Array<Player>}
     * @memberof RedProtectRegion
     */
    admins?: Array<Player>;
    /**
     * True if this region can be deleted, false otherwise
     * @type {boolean}
     * @memberof RedProtectRegion
     */
    canDelete?: boolean;
    /**
     * The date this region was created?
     * @type {string}
     * @memberof RedProtectRegion
     */
    date?: string;
    /**
     * A map of flags applicable to this region
     * @type {{ [key: string]: any; }}
     * @memberof RedProtectRegion
     */
    flags?: { [key: string]: any; };
    /**
     * A list of players that are leaders of this region
     * @type {Array<Player>}
     * @memberof RedProtectRegion
     */
    leaders?: Array<Player>;
    /**
     * A list of players that are members of this region
     * @type {Array<Player>}
     * @memberof RedProtectRegion
     */
    members?: Array<Player>;
    /**
     * The priority of this region compared to other regions
     * @type {number}
     * @memberof RedProtectRegion
     */
    priority?: number;
    /**
     * The teleport point for this region
     * @type {Location}
     * @memberof RedProtectRegion
     */
    tpPoint?: Location;
    /**
     * The welcome message displayed to a player when they enter this region
     * @type {string}
     * @memberof RedProtectRegion
     */
    welcomeMessage?: string;
}

/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    delay?: number;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    interval?: number;
}

/**
 * 
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {PluginContainer}
     * @memberof ServerInfo
     */
    api: PluginContainer;
    /**
     * 
     * @type {PluginContainer}
     * @memberof ServerInfo
     */
    game: PluginContainer;
    /**
     * True if the server has activated the whitelist, false otherwise
     * @type {boolean}
     * @memberof ServerInfo
     */
    hasWhitelist: boolean;
    /**
     * 
     * @type {PluginContainer}
     * @memberof ServerInfo
     */
    implementation: PluginContainer;
    /**
     * The maximum amount of players allowed on the server
     * @type {number}
     * @memberof ServerInfo
     */
    maxPlayers: number;
    /**
     * The Minecraft version running on the server
     * @type {string}
     * @memberof ServerInfo
     */
    minecraftVersion: string;
    /**
     * The message of the day set on the server
     * @type {string}
     * @memberof ServerInfo
     */
    motd: string;
    /**
     * True if the server is in online mode and verifies connections, false otherwise
     * @type {boolean}
     * @memberof ServerInfo
     */
    onlineMode: boolean;
    /**
     * The amount of players currently playing on the server
     * @type {number}
     * @memberof ServerInfo
     */
    players: number;
    /**
     * The average ticks per second the server is running with
     * @type {number}
     * @memberof ServerInfo
     */
    tps: number;
    /**
     * The number of ticks the server has been running
     * @type {number}
     * @memberof ServerInfo
     */
    uptimeTicks: number;
    /**
     * The address that the server is bound to
     * @type {string}
     * @memberof ServerInfo
     */
    address?: string;
    /**
     * The name of the resource pack this is used on the server
     * @type {string}
     * @memberof ServerInfo
     */
    resourcePack?: string;
}

/**
 * 
 * @export
 * @interface ServerProperty
 */
export interface ServerProperty {
    /**
     * The key of the server property
     * @type {string}
     * @memberof ServerProperty
     */
    key: string;
    /**
     * The value of the server property
     * @type {string}
     * @memberof ServerProperty
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ServerReport
 */
export interface ServerReport {
    /**
     * 
     * @type {TimeHolder}
     * @memberof ServerReport
     */
    dailyAverage?: TimeHolder;
    /**
     * 
     * @type {LocalDate}
     * @memberof ServerReport
     */
    from?: LocalDate;
    /**
     * 
     * @type {TimeHolder}
     * @memberof ServerReport
     */
    monthlyAverage?: TimeHolder;
    /**
     * 
     * @type {LocalDate}
     * @memberof ServerReport
     */
    to?: LocalDate;
    /**
     * 
     * @type {TimeHolder}
     * @memberof ServerReport
     */
    total?: TimeHolder;
    /**
     * 
     * @type {TimeHolder}
     * @memberof ServerReport
     */
    weeklyAverage?: TimeHolder;
}

/**
 * 
 * @export
 * @interface ServerStat
 */
export interface ServerStat {
    /**
     * The epoch timestamp (in seconds) when the statistic was recorded
     * @type {number}
     * @memberof ServerStat
     */
    timestamp: number;
    /**
     * The value that was recorded
     * @type {number}
     * @memberof ServerStat
     */
    value: number;
}

/**
 * 
 * @export
 * @interface ServerStatDouble
 */
export interface ServerStatDouble {
    /**
     * The epoch timestamp (in seconds) when the statistic was recorded
     * @type {number}
     * @memberof ServerStatDouble
     */
    timestamp: number;
    /**
     * The value that was recorded
     * @type {number}
     * @memberof ServerStatDouble
     */
    value: number;
}

/**
 * 
 * @export
 * @interface ServerStatInteger
 */
export interface ServerStatInteger {
    /**
     * The epoch timestamp (in seconds) when the statistic was recorded
     * @type {number}
     * @memberof ServerStatInteger
     */
    timestamp: number;
    /**
     * The value that was recorded
     * @type {number}
     * @memberof ServerStatInteger
     */
    value: number;
}

/**
 * 
 * @export
 * @interface ServerStats
 */
export interface ServerStats {
    /**
     * Historic values for the cpu load
     * @type {Array<ServerStatDouble>}
     * @memberof ServerStats
     */
    cpu: Array<ServerStatDouble>;
    /**
     * Historic values for the disk usage
     * @type {Array<ServerStatDouble>}
     * @memberof ServerStats
     */
    disk: Array<ServerStatDouble>;
    /**
     * Historic values for the memory load
     * @type {Array<ServerStatDouble>}
     * @memberof ServerStats
     */
    memory: Array<ServerStatDouble>;
    /**
     * Historic values for the number of online players
     * @type {Array<ServerStatInteger>}
     * @memberof ServerStats
     */
    players: Array<ServerStatInteger>;
    /**
     * Historic values for the average ticks per second
     * @type {Array<ServerStatDouble>}
     * @memberof ServerStats
     */
    tps: Array<ServerStatDouble>;
}

/**
 * 
 * @export
 * @interface SlimeData
 */
export interface SlimeData {
    /**
     * The size of the slime entity
     * @type {number}
     * @memberof SlimeData
     */
    size: number;
}

/**
 * 
 * @export
 * @interface Slot
 */
export interface Slot {
    /**
     * The item stack that is in this slot
     * @type {ItemStack}
     * @memberof Slot
     */
    stack: ItemStack;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof Slot
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof Slot
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    axis?: Slot.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof Slot
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof Slot
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof Slot
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof Slot
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof Slot
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof Slot
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof Slot
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof Slot
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slot
     */
    connectedDirection?: Array<Slot.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof Slot
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof Slot
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    direction?: Slot.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof Slot
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof Slot
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Slot
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof Slot
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof Slot
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof Slot
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof Slot
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof Slot
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof Slot
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof Slot
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof Slot
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof Slot
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof Slot
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof Slot
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof Slot
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof Slot
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof Slot
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof Slot
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof Slot
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    inWall?: boolean;
    /**
     * 
     * @type {Inventory}
     * @memberof Slot
     */
    inventory?: Inventory;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof Slot
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof Slot
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof Slot
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof Slot
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slot
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof Slot
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof Slot
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slot
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slot
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof Slot
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof Slot
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Slot
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof Slot
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof Slot
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slot
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof Slot
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof Slot
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof Slot
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof Slot
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof Slot
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof Slot
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof Slot
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof Slot
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof Slot
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof Slot
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof Slot
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof Slot
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof Slot
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof Slot
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof Slot
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof Slot
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof Slot
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof Slot
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof Slot
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    matter?: Slot.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof Slot
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof Slot
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof Slot
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof Slot
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slot
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace Slot
 */
export namespace Slot {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface SlotIndex
 */
export interface SlotIndex {
    /**
     * 
     * @type {string}
     * @memberof SlotIndex
     */
    operator?: SlotIndex.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof SlotIndex
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof SlotIndex
     */
    value?: number;
}

/**
 * @export
 * @namespace SlotIndex
 */
export namespace SlotIndex {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface SlotPos
 */
export interface SlotPos {
    /**
     * 
     * @type {string}
     * @memberof SlotPos
     */
    operator?: SlotPos.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof SlotPos
     */
    key?: string;
    /**
     * 
     * @type {Vector2i}
     * @memberof SlotPos
     */
    value?: Vector2i;
    /**
     * 
     * @type {number}
     * @memberof SlotPos
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof SlotPos
     */
    x?: number;
}

/**
 * @export
 * @namespace SlotPos
 */
export namespace SlotPos {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
}

/**
 * 
 * @export
 * @interface SlotRequest
 */
export interface SlotRequest {
    /**
     * The index of the slot to change
     * @type {number}
     * @memberof SlotRequest
     */
    slotIndex?: number;
    /**
     * The ItemStack that should be in the slot. null for an empty slot
     * @type {ItemStack}
     * @memberof SlotRequest
     */
    stack?: ItemStack;
}

/**
 * 
 * @export
 * @interface SlotSide
 */
export interface SlotSide {
    /**
     * 
     * @type {string}
     * @memberof SlotSide
     */
    operator?: SlotSide.OperatorEnum;
    /**
     * 
     * @type {string}
     * @memberof SlotSide
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof SlotSide
     */
    value?: SlotSide.ValueEnum;
}

/**
 * @export
 * @namespace SlotSide
 */
export namespace SlotSide {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        DELEGATE = <any> 'DELEGATE',
        EQUAL = <any> 'EQUAL',
        NOTEQUAL = <any> 'NOTEQUAL',
        GREATER = <any> 'GREATER',
        GEQUAL = <any> 'GEQUAL',
        LESS = <any> 'LESS',
        LEQUAL = <any> 'LEQUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
}

/**
 * 
 * @export
 * @interface Stat
 */
export interface Stat {
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    stat?: string;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface StructureData
 */
export interface StructureData {
    /**
     * The author of this structure
     * @type {string}
     * @memberof StructureData
     */
    author: string;
    /**
     * True if entities are not part of this structure, false otherwise
     * @type {boolean}
     * @memberof StructureData
     */
    ignoreEntities: boolean;
    /**
     * The integrity of the structure
     * @type {number}
     * @memberof StructureData
     */
    integrity: number;
    /**
     * The mode of the structure
     * @type {CatalogType}
     * @memberof StructureData
     */
    mode: CatalogType;
    /**
     * The position of the structure
     * @type {Vector3i}
     * @memberof StructureData
     */
    position: Vector3i;
    /**
     * True if the structure is powered, false otherwise
     * @type {boolean}
     * @memberof StructureData
     */
    powered: boolean;
    /**
     * The seed of this structure
     * @type {number}
     * @memberof StructureData
     */
    seed: number;
    /**
     * True if the air blocks for this structure are shown, false otherwise
     * @type {boolean}
     * @memberof StructureData
     */
    showAir: boolean;
    /**
     * True if the bounding box for this structure is shown, false otherwise
     * @type {boolean}
     * @memberof StructureData
     */
    showBoundingBox: boolean;
    /**
     * The size of this structure
     * @type {Vector3i}
     * @memberof StructureData
     */
    size: Vector3i;
}

/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * The unique id of this subject
     * @type {string}
     * @memberof Subject
     */
    id: string;
    /**
     * The friendly id of this subject (often a 'name'
     * @type {string}
     * @memberof Subject
     */
    friendlyId?: string;
    /**
     * The permissions that are assigned to this subject
     * @type {{ [key: string]: boolean; }}
     * @memberof Subject
     */
    permissions?: { [key: string]: boolean; };
}

/**
 * 
 * @export
 * @interface SubjectCollection
 */
export interface SubjectCollection {
    /**
     * The unique id of this subject collection
     * @type {string}
     * @memberof SubjectCollection
     */
    id: string;
    /**
     * The amount of subjects currently loaded from this collection
     * @type {number}
     * @memberof SubjectCollection
     */
    loadedSubjectCount: number;
}

/**
 * 
 * @export
 * @interface TableEntry
 */
export interface TableEntry {
    /**
     * 
     * @type {number}
     * @memberof TableEntry
     */
    weight?: number;
}

/**
 * 
 * @export
 * @interface TableEntryEntityArchetype
 */
export interface TableEntryEntityArchetype {
    /**
     * 
     * @type {number}
     * @memberof TableEntryEntityArchetype
     */
    weight?: number;
}

/**
 * 
 * @export
 * @interface TameableData
 */
export interface TameableData {
    /**
     * True if this entity is tamed, false otherwise
     * @type {boolean}
     * @memberof TameableData
     */
    tamed: boolean;
    /**
     * The UUID of the entity which tamed this entity
     * @type {string}
     * @memberof TameableData
     */
    owner?: string;
}

/**
 * 
 * @export
 * @interface TileEntity
 */
export interface TileEntity {
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof TileEntity
     */
    link: string;
    /**
     * The location of this tile entity
     * @type {Location}
     * @memberof TileEntity
     */
    location: Location;
    /**
     * The type of this tile entity
     * @type {CatalogType}
     * @memberof TileEntity
     */
    type: CatalogType;
    /**
     * 
     * @type {Inventory}
     * @memberof TileEntity
     */
    inventory?: Inventory;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof TileEntity
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof TileEntity
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    axis?: TileEntity.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof TileEntity
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof TileEntity
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof TileEntity
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof TileEntity
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof TileEntity
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof TileEntity
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof TileEntity
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof TileEntity
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof TileEntity
     */
    connectedDirection?: Array<TileEntity.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof TileEntity
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof TileEntity
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    direction?: TileEntity.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof TileEntity
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof TileEntity
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof TileEntity
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof TileEntity
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof TileEntity
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof TileEntity
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof TileEntity
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof TileEntity
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof TileEntity
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof TileEntity
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof TileEntity
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof TileEntity
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof TileEntity
     */
    fuse?: FuseData;
    /**
     * 
     * @type {GameMode}
     * @memberof TileEntity
     */
    gameMode?: GameMode;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof TileEntity
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof TileEntity
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof TileEntity
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof TileEntity
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof TileEntity
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    inWall?: boolean;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof TileEntity
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof TileEntity
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof TileEntity
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof TileEntity
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof TileEntity
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof TileEntity
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof TileEntity
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof TileEntity
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TileEntity
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof TileEntity
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof TileEntity
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof TileEntity
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof TileEntity
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof TileEntity
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof TileEntity
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof TileEntity
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    snow?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    spawn?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof TileEntity
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof TileEntity
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof TileEntity
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof TileEntity
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof TileEntity
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof TileEntity
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof TileEntity
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof TileEntity
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof TileEntity
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof TileEntity
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof TileEntity
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof TileEntity
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof TileEntity
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof TileEntity
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof TileEntity
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof TileEntity
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof TileEntity
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof TileEntity
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof TileEntity
     */
    matter?: TileEntity.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof TileEntity
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof TileEntity
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof TileEntity
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof TileEntity
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof TileEntity
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TileEntity
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace TileEntity
 */
export namespace TileEntity {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface TimeHolder
 */
export interface TimeHolder {
    /**
     * The amount of active time spent
     * @type {number}
     * @memberof TimeHolder
     */
    activeTime?: number;
    /**
     * The amount of time spent afk (only works if Nucleus is present)
     * @type {number}
     * @memberof TimeHolder
     */
    afkTime?: number;
}

/**
 * 
 * @export
 * @interface TradeOffer
 */
export interface TradeOffer {
    /**
     * True if this offer is expired, false otherwise
     * @type {boolean}
     * @memberof TradeOffer
     */
    expired: boolean;
    /**
     * True if this trade grants experience when completed, false otherwise
     * @type {boolean}
     * @memberof TradeOffer
     */
    grantsExp: boolean;
    /**
     * The amount of times this trade has been used
     * @type {number}
     * @memberof TradeOffer
     */
    uses: number;
    /**
     * The maximum amount of times that this trade can be used
     * @type {number}
     * @memberof TradeOffer
     */
    maxUses: number;
    /**
     * The first item that is required for the trade
     * @type {ItemStack}
     * @memberof TradeOffer
     */
    firstBuyingItem: ItemStack;
    /**
     * The second item that is required for the trade
     * @type {ItemStack}
     * @memberof TradeOffer
     */
    secondBuyingItem?: ItemStack;
    /**
     * The item that is received when trading
     * @type {ItemStack}
     * @memberof TradeOffer
     */
    sellingItem: ItemStack;
}

/**
 * 
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * The world of this transform
     * @type {World}
     * @memberof Transform
     */
    world: World;
    /**
     * The position within the world
     * @type {Vector3d}
     * @memberof Transform
     */
    position: Vector3d;
    /**
     * The rotation of the object
     * @type {Vector3d}
     * @memberof Transform
     */
    rotation: Vector3d;
    /**
     * The scale of the object
     * @type {Vector3d}
     * @memberof Transform
     */
    scale: Vector3d;
}

/**
 * 
 * @export
 * @interface UniversalMarketItem
 */
export interface UniversalMarketItem {
    /**
     * The ItemStack displayed to the users
     * @type {ItemStack}
     * @memberof UniversalMarketItem
     */
    display: ItemStack;
    /**
     * The unix timestamp (in seconds) at which this offer will expire
     * @type {number}
     * @memberof UniversalMarketItem
     */
    expires: number;
    /**
     * The ItemStack that is being sold
     * @type {ItemStack}
     * @memberof UniversalMarketItem
     */
    item: ItemStack;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof UniversalMarketItem
     */
    link: string;
    /**
     * The owner that submitted this offer
     * @type {Player}
     * @memberof UniversalMarketItem
     */
    owner: Player;
    /**
     * The price this item is being sold for
     * @type {number}
     * @memberof UniversalMarketItem
     */
    price: number;
}

/**
 * 
 * @export
 * @interface UpdateEntityRequest
 */
export interface UpdateEntityRequest {
    /**
     * The damage the entity will take
     * @type {DamageRequest}
     * @memberof UpdateEntityRequest
     */
    damage?: DamageRequest;
    /**
     * The slots in the inventory of the entity to modify
     * @type {Array<SlotRequest>}
     * @memberof UpdateEntityRequest
     */
    inventory?: Array<SlotRequest>;
    /**
     * The position that the entity will be moved to
     * @type {Vector3d}
     * @memberof UpdateEntityRequest
     */
    position?: Vector3d;
    /**
     * The new rotation of the entity
     * @type {Vector3d}
     * @memberof UpdateEntityRequest
     */
    rotation?: Vector3d;
    /**
     * The new scale of the entity
     * @type {Vector3d}
     * @memberof UpdateEntityRequest
     */
    scale?: Vector3d;
    /**
     * The new speed of the entity
     * @type {Vector3d}
     * @memberof UpdateEntityRequest
     */
    velocity?: Vector3d;
    /**
     * The world that the entity will be moved to
     * @type {string}
     * @memberof UpdateEntityRequest
     */
    world?: string;
}

/**
 * 
 * @export
 * @interface UpdatePlayerRequest
 */
export interface UpdatePlayerRequest {
    /**
     * The damage the entity will take
     * @type {DamageRequest}
     * @memberof UpdatePlayerRequest
     */
    damage?: DamageRequest;
    /**
     * The exhaustion of the player
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    exhaustion?: number;
    /**
     * The amount of experience gained since the last level
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    experienceSinceLevel?: number;
    /**
     * The food level of the player
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    foodLevel?: number;
    /**
     * The game mode of the player
     * @type {string}
     * @memberof UpdatePlayerRequest
     */
    gameMode?: string;
    /**
     * The current amount of health the player has
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    health?: number;
    /**
     * The slots in the inventory of the entity to modify
     * @type {Array<SlotRequest>}
     * @memberof UpdatePlayerRequest
     */
    inventory?: Array<SlotRequest>;
    /**
     * The player level
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    level?: number;
    /**
     * The maximum health of the player
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    maxHealth?: number;
    /**
     * The position that the entity will be moved to
     * @type {Vector3d}
     * @memberof UpdatePlayerRequest
     */
    position?: Vector3d;
    /**
     * The new rotation of the entity
     * @type {Vector3d}
     * @memberof UpdatePlayerRequest
     */
    rotation?: Vector3d;
    /**
     * The saturation of the player
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    saturation?: number;
    /**
     * The new scale of the entity
     * @type {Vector3d}
     * @memberof UpdatePlayerRequest
     */
    scale?: Vector3d;
    /**
     * The total experience of the player
     * @type {number}
     * @memberof UpdatePlayerRequest
     */
    totalExperience?: number;
    /**
     * The new speed of the entity
     * @type {Vector3d}
     * @memberof UpdatePlayerRequest
     */
    velocity?: Vector3d;
    /**
     * The world that the entity will be moved to
     * @type {string}
     * @memberof UpdatePlayerRequest
     */
    world?: string;
}

/**
 * 
 * @export
 * @interface UpdateTileEntityRequest
 */
export interface UpdateTileEntityRequest {
    /**
     * The ItemStacks in the inventory of the tile entity
     * @type {Array<ItemStack>}
     * @memberof UpdateTileEntityRequest
     */
    inventory?: Array<ItemStack>;
}

/**
 * 
 * @export
 * @interface UpdateWorldRequest
 */
export interface UpdateWorldRequest {
    /**
     * The name of the world
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorldRequest
     */
    allowCommands?: boolean;
    /**
     * Which difficulty the world is set to
     * @type {CatalogType}
     * @memberof UpdateWorldRequest
     */
    difficulty?: CatalogType;
    /**
     * Which game mode the world defaults to
     * @type {GameMode}
     * @memberof UpdateWorldRequest
     */
    gameMode?: GameMode;
    /**
     * The game rule settings of this world
     * @type {{ [key: string]: string; }}
     * @memberof UpdateWorldRequest
     */
    gameRules?: { [key: string]: string; };
    /**
     * Which generator to use for the world
     * @type {CatalogType}
     * @memberof UpdateWorldRequest
     */
    generator?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorldRequest
     */
    keepSpawnLoaded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorldRequest
     */
    loadOnStartup?: boolean;
    /**
     * True if the world should be loaded, false otherwise
     * @type {boolean}
     * @memberof UpdateWorldRequest
     */
    loaded?: boolean;
    /**
     * The seed of the world
     * @type {number}
     * @memberof UpdateWorldRequest
     */
    seed?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWorldRequest
     */
    usesMapFeatures?: boolean;
}

/**
 * 
 * @export
 * @interface UserPermissionStruct
 */
export interface UserPermissionStruct {
    /**
     * The key used authorize with the Web-API
     * @type {string}
     * @memberof UserPermissionStruct
     */
    key: string;
    /**
     * The human readable name of this permssions struct. Only useful for users.
     * @type {string}
     * @memberof UserPermissionStruct
     */
    name: string;
    /**
     * The permissions tree that this key grants access to
     * @type {any}
     * @memberof UserPermissionStruct
     */
    permissions: any;
    /**
     * The rate limit in requests per second that this key permits (0 = unlimited)
     * @type {number}
     * @memberof UserPermissionStruct
     */
    rateLimit: number;
}

/**
 * 
 * @export
 * @interface UserReport
 */
export interface UserReport {
    /**
     * 
     * @type {TimeHolder}
     * @memberof UserReport
     */
    dailyAverage?: TimeHolder;
    /**
     * 
     * @type {LocalDate}
     * @memberof UserReport
     */
    from?: LocalDate;
    /**
     * 
     * @type {TimeHolder}
     * @memberof UserReport
     */
    monthlyAverage?: TimeHolder;
    /**
     * 
     * @type {string}
     * @memberof UserReport
     */
    name?: string;
    /**
     * 
     * @type {LocalDate}
     * @memberof UserReport
     */
    to?: LocalDate;
    /**
     * 
     * @type {TimeHolder}
     * @memberof UserReport
     */
    total?: TimeHolder;
    /**
     * 
     * @type {string}
     * @memberof UserReport
     */
    uuid?: string;
    /**
     * 
     * @type {TimeHolder}
     * @memberof UserReport
     */
    weeklyAverage?: TimeHolder;
}

/**
 * 
 * @export
 * @interface Vector2i
 */
export interface Vector2i {
    /**
     * 
     * @type {number}
     * @memberof Vector2i
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Vector2i
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof Vector2i
     */
    minAxis?: number;
    /**
     * 
     * @type {number}
     * @memberof Vector2i
     */
    maxAxis?: number;
}

/**
 * 
 * @export
 * @interface Vector3d
 */
export interface Vector3d {
    /**
     * The x-coordinate
     * @type {number}
     * @memberof Vector3d
     */
    x: number;
    /**
     * The y-coordinate
     * @type {number}
     * @memberof Vector3d
     */
    y: number;
    /**
     * The z-coordinate
     * @type {number}
     * @memberof Vector3d
     */
    z: number;
}

/**
 * 
 * @export
 * @interface Vector3i
 */
export interface Vector3i {
    /**
     * The x-coordinate
     * @type {number}
     * @memberof Vector3i
     */
    x: number;
    /**
     * The y-coordinate
     * @type {number}
     * @memberof Vector3i
     */
    y: number;
    /**
     * The z-coordinate
     * @type {number}
     * @memberof Vector3i
     */
    z: number;
}

/**
 * 
 * @export
 * @interface VehicleData
 */
export interface VehicleData {
    /**
     * The base vehicle entity
     * @type {EntitySnapshot}
     * @memberof VehicleData
     */
    baseVehicle: EntitySnapshot;
    /**
     * The vehicle entity itself
     * @type {EntitySnapshot}
     * @memberof VehicleData
     */
    vehicle: EntitySnapshot;
}

/**
 * 
 * @export
 * @interface VillagerShopsShop
 */
export interface VillagerShopsShop {
    /**
     * The minecraft entity type string for this shops visual entity
     * @type {CatalogTypeEntityType}
     * @memberof VillagerShopsShop
     */
    entityType: CatalogTypeEntityType;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof VillagerShopsShop
     */
    link: string;
    /**
     * A very dynamic variant string for vanilla mobs, most variants as in the minecraft wiki should be supported
     * @type {string}
     * @memberof VillagerShopsShop
     */
    entityVariant?: string;
    /**
     * Where the shop is currently located
     * @type {Location}
     * @memberof VillagerShopsShop
     */
    location?: Location;
    /**
     * The escaped shop name
     * @type {string}
     * @memberof VillagerShopsShop
     */
    name?: string;
    /**
     * If this shop is a player shop this conatins the UUID of this shops owner. Omitting this field or setting it to null will remove the player-shop association.
     * @type {string}
     * @memberof VillagerShopsShop
     */
    owner?: string;
    /**
     * The mobs roations around their up-axis
     * @type {number}
     * @memberof VillagerShopsShop
     */
    rotation?: number;
    /**
     * Location where a container should reside for stocking items. Omitting this field or setting it to null will remove the stock container. Having a player-shop without container is undefined behaviour!
     * @type {Location}
     * @memberof VillagerShopsShop
     */
    stockContainer?: Location;
    /**
     * Returns a list of all stock items currently listed. This property is read only.
     * @type {Array<VillagerShopsStockItem>}
     * @memberof VillagerShopsShop
     */
    stockItems?: Array<VillagerShopsStockItem>;
    /**
     * The unique shop identifier; this is not the mob uuid
     * @type {string}
     * @memberof VillagerShopsShop
     */
    uid?: string;
}

/**
 * 
 * @export
 * @interface VillagerShopsStockItem
 */
export interface VillagerShopsStockItem {
    /**
     * The amount of money this stack consts to buy as player
     * @type {number}
     * @memberof VillagerShopsStockItem
     */
    buyPrice: number;
    /**
     * The currency for this item listing
     * @type {CatalogTypeCurrency}
     * @memberof VillagerShopsStockItem
     */
    currency: CatalogTypeCurrency;
    /**
     * Returns wether this shop has a limited stock
     * @type {boolean}
     * @memberof VillagerShopsStockItem
     */
    hasStock: boolean;
    /**
     * The raw ItemStack data for this shop listing
     * @type {ItemStack}
     * @memberof VillagerShopsStockItem
     */
    item: ItemStack;
    /**
     * If this shop has a limited stock, returns how many of these items can be stocked, 0 is unlimited
     * @type {number}
     * @memberof VillagerShopsStockItem
     */
    maxStock: number;
    /**
     * The amount of money this stack earns the player when selling
     * @type {number}
     * @memberof VillagerShopsStockItem
     */
    sellPrice: number;
    /**
     * The shop uuid offering this item listing
     * @type {string}
     * @memberof VillagerShopsStockItem
     */
    shopId: string;
    /**
     * If this shop has a limited stock, returns how many items are stocked, otherwise returns items stack size
     * @type {number}
     * @memberof VillagerShopsStockItem
     */
    stock: number;
    /**
     * The index of this item withing the shops inventory
     * @type {number}
     * @memberof VillagerShopsStockItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VillagerShopsStockItem
     */
    link?: string;
}

/**
 * 
 * @export
 * @interface WebBooksBook
 */
export interface WebBooksBook {
    /**
     * The HTML representation of this book
     * @type {string}
     * @memberof WebBooksBook
     */
    html: string;
    /**
     * The unique id of this book
     * @type {string}
     * @memberof WebBooksBook
     */
    id: string;
    /**
     * A list of lines that make up this book
     * @type {Array<string>}
     * @memberof WebBooksBook
     */
    lines: Array<string>;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof WebBooksBook
     */
    link: string;
    /**
     * The title of this book
     * @type {string}
     * @memberof WebBooksBook
     */
    title: string;
}

/**
 * 
 * @export
 * @interface WireAttachmentData
 */
export interface WireAttachmentData {
    /**
     * The type of wire attachment to the east of this entity
     * @type {CatalogType}
     * @memberof WireAttachmentData
     */
    east: CatalogType;
    /**
     * The type of wire attachment to the north of this entity
     * @type {CatalogType}
     * @memberof WireAttachmentData
     */
    north: CatalogType;
    /**
     * The type of wire attachment to the south of this entity
     * @type {CatalogType}
     * @memberof WireAttachmentData
     */
    south: CatalogType;
    /**
     * The type of wire attachment to the west of this entity
     * @type {CatalogType}
     * @memberof WireAttachmentData
     */
    west: CatalogType;
}

/**
 * 
 * @export
 * @interface World
 */
export interface World {
    /**
     * True if commands are allowed to be executed in this world, false otherwise
     * @type {boolean}
     * @memberof World
     */
    allowCommands: boolean;
    /**
     * The border of the world
     * @type {WorldBorder}
     * @memberof World
     */
    border: WorldBorder;
    /**
     * The difficulty of the world
     * @type {CatalogTypeDifficulty}
     * @memberof World
     */
    difficulty: CatalogTypeDifficulty;
    /**
     * The dimension of the world
     * @type {CatalogTypeDimensionType}
     * @memberof World
     */
    dimensionType: CatalogTypeDimensionType;
    /**
     * 
     * @type {GameMode}
     * @memberof World
     */
    gameMode?: GameMode;
    /**
     * A map of world rule names to values
     * @type {{ [key: string]: string; }}
     * @memberof World
     */
    gameRules: { [key: string]: string; };
    /**
     * True if bonus chests are generated for this world, false otherwise
     * @type {boolean}
     * @memberof World
     */
    generateBonusChests: boolean;
    /**
     * The generator type used for this world
     * @type {CatalogTypeGeneratorType}
     * @memberof World
     */
    generatorType: CatalogTypeGeneratorType;
    /**
     * True if the spawn of this world is always kept loaded, false otherwise
     * @type {boolean}
     * @memberof World
     */
    keepSpawnLoaded: boolean;
    /**
     * The API link that can be used to obtain more information about this object
     * @type {string}
     * @memberof World
     */
    link: string;
    /**
     * True if this world is loaded when the server starts, false otherwise
     * @type {boolean}
     * @memberof World
     */
    loadOnStartup: boolean;
    /**
     * True if the world is loaded, false otherwise
     * @type {boolean}
     * @memberof World
     */
    loaded: boolean;
    /**
     * True if map specific features are enabled for this world, false otherwise
     * @type {boolean}
     * @memberof World
     */
    mapFeaturesEnabled: boolean;
    /**
     * The name of this world
     * @type {string}
     * @memberof World
     */
    name: string;
    /**
     * The seed of the world
     * @type {number}
     * @memberof World
     */
    seed: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    spawn?: CatalogType;
    /**
     * The current time in the world
     * @type {number}
     * @memberof World
     */
    time: number;
    /**
     * The unique UUID that identifies this world
     * @type {string}
     * @memberof World
     */
    uuid: string;
    /**
     * The current weather in the world
     * @type {CatalogTypeWeather}
     * @memberof World
     */
    weather: CatalogTypeWeather;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    absorption?: number;
    /**
     * 
     * @type {AgeableData}
     * @memberof World
     */
    age?: AgeableData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    aggressive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    aiEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    angerLevel?: number;
    /**
     * 
     * @type {ArmorStandData}
     * @memberof World
     */
    armorStand?: ArmorStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    art?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    attached?: boolean;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    axis?: World.AxisEnum;
    /**
     * 
     * @type {BannerData}
     * @memberof World
     */
    banner?: BannerData;
    /**
     * 
     * @type {BeaconData}
     * @memberof World
     */
    beacon?: BeaconData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    bigMushroom?: CatalogType;
    /**
     * 
     * @type {BlockState}
     * @memberof World
     */
    block?: BlockState;
    /**
     * 
     * @type {BreathingData}
     * @memberof World
     */
    breathing?: BreathingData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    breedable?: boolean;
    /**
     * 
     * @type {BrewingStandData}
     * @memberof World
     */
    brewingStand?: BrewingStandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    brick?: CatalogType;
    /**
     * 
     * @type {Career}
     * @memberof World
     */
    career?: Career;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    charged?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    coal?: CatalogType;
    /**
     * 
     * @type {Color}
     * @memberof World
     */
    color?: Color;
    /**
     * 
     * @type {CommandData}
     * @memberof World
     */
    command?: CommandData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    comparator?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    connectedDirection?: Array<World.ConnectedDirectionEnum>;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    cookedFish?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    cooldown?: number;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    criticalHit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    customName?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    damage?: number;
    /**
     * 
     * @type {DamageableData}
     * @memberof World
     */
    damageable?: DamageableData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    decayable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    delay?: number;
    /**
     * 
     * @type {DespawnDelayData}
     * @memberof World
     */
    despawnDelay?: DespawnDelayData;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    direction?: World.DirectionEnum;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    dirt?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    disarmed?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    disguisedBlock?: CatalogType;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    displayName?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    dominantHand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    doublePlant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    drops?: boolean;
    /**
     * 
     * @type {DurabilityData}
     * @memberof World
     */
    durability?: DurabilityData;
    /**
     * 
     * @type {DyeColor}
     * @memberof World
     */
    dye?: DyeColor;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof World
     */
    enchantments?: Array<Enchantment>;
    /**
     * 
     * @type {EndGatewayData}
     * @memberof World
     */
    endGateway?: EndGatewayData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    expOrb?: number;
    /**
     * 
     * @type {ExperienceHolderData}
     * @memberof World
     */
    experience?: ExperienceHolderData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    expireTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    explosionRadius?: number;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    extended?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    fallDistance?: number;
    /**
     * 
     * @type {FallingBlockData}
     * @memberof World
     */
    fallingBlock?: FallingBlockData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    filled?: boolean;
    /**
     * 
     * @type {Array<FireworkEffect>}
     * @memberof World
     */
    fireworkEffects?: Array<FireworkEffect>;
    /**
     * 
     * @type {FireworkRocketData}
     * @memberof World
     */
    fireworkRocket?: FireworkRocketData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    fish?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    flammable?: boolean;
    /**
     * 
     * @type {FluidStack}
     * @memberof World
     */
    fluid?: FluidStack;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    fluidLevel?: number;
    /**
     * 
     * @type {{ [key: string]: Array<FluidStack>; }}
     * @memberof World
     */
    fluidTanks?: { [key: string]: Array<FluidStack>; };
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    flying?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    flyingAbility?: boolean;
    /**
     * 
     * @type {FoodData}
     * @memberof World
     */
    food?: FoodData;
    /**
     * 
     * @type {FurnaceData}
     * @memberof World
     */
    furnace?: FurnaceData;
    /**
     * 
     * @type {FuseData}
     * @memberof World
     */
    fuse?: FuseData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    generation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    glowing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    goldenApple?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    griefs?: boolean;
    /**
     * 
     * @type {GrowthData}
     * @memberof World
     */
    growth?: GrowthData;
    /**
     * 
     * @type {HealthData}
     * @memberof World
     */
    health?: HealthData;
    /**
     * 
     * @type {HideData}
     * @memberof World
     */
    hide?: HideData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    hinge?: CatalogType;
    /**
     * 
     * @type {HorseData}
     * @memberof World
     */
    horse?: HorseData;
    /**
     * 
     * @type {IgniteableData}
     * @memberof World
     */
    igniteable?: IgniteableData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    inWall?: boolean;
    /**
     * 
     * @type {Inventory}
     * @memberof World
     */
    inventory?: Inventory;
    /**
     * 
     * @type {InvisibilityData}
     * @memberof World
     */
    invisibility?: InvisibilityData;
    /**
     * 
     * @type {InvulnerabilityData}
     * @memberof World
     */
    invulnerability?: InvulnerabilityData;
    /**
     * 
     * @type {JoinData}
     * @memberof World
     */
    joined?: JoinData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    knockback?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    layer?: number;
    /**
     * 
     * @type {LeashData}
     * @memberof World
     */
    leash?: LeashData;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    lockToken?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    logAxis?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    lore?: Array<string>;
    /**
     * 
     * @type {MinecartBlockData}
     * @memberof World
     */
    minecartBlock?: MinecartBlockData;
    /**
     * 
     * @type {MobSpawnerData}
     * @memberof World
     */
    mobSpawner?: MobSpawnerData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    moisture?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    note?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    occupied?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    ocelot?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    open?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    pages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    passengers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    persists?: boolean;
    /**
     * 
     * @type {PickupDelayData}
     * @memberof World
     */
    pickupDelay?: PickupDelayData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    pickupRule?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    pigSaddle?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    piston?: CatalogType;
    /**
     * 
     * @type {Array<CatalogType>}
     * @memberof World
     */
    placeableOn?: Array<CatalogType>;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    plant?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    playerCreated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    playing?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    portion?: CatalogType;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof World
     */
    potionEffects?: Array<PotionEffect>;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    powered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    prismarine?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    quartz?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    rabbit?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    railDirection?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    redstonePower?: number;
    /**
     * 
     * @type {ItemStack}
     * @memberof World
     */
    representedItem?: ItemStack;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    representedPlayer?: string;
    /**
     * 
     * @type {{ [key: string]: Location; }}
     * @memberof World
     */
    respawnLocations?: { [key: string]: Location; };
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    sand?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    sandStone?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    screaming?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    seamless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    shatters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    sheared?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    shrub?: CatalogType;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    sign?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    silent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    sitting?: boolean;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    skin?: string;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    skull?: CatalogType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    slab?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    sleeping?: boolean;
    /**
     * 
     * @type {SlimeData}
     * @memberof World
     */
    slime?: SlimeData;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    sneaking?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    snow?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    sprinting?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    stairShape?: CatalogType;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof World
     */
    statistics?: Array<Stat>;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    stone?: CatalogType;
    /**
     * 
     * @type {Array<Enchantment>}
     * @memberof World
     */
    storedEnchantments?: Array<Enchantment>;
    /**
     * 
     * @type {StructureData}
     * @memberof World
     */
    structure?: StructureData;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    stuckArrows?: number;
    /**
     * 
     * @type {TameableData}
     * @memberof World
     */
    tamed?: TameableData;
    /**
     * 
     * @type {Vector3d}
     * @memberof World
     */
    target?: Vector3d;
    /**
     * 
     * @type {Array<TradeOffer>}
     * @memberof World
     */
    trades?: Array<TradeOffer>;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    tree?: CatalogType;
    /**
     * 
     * @type {VehicleData}
     * @memberof World
     */
    vehicle?: VehicleData;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    wall?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    wet?: boolean;
    /**
     * 
     * @type {WireAttachmentData}
     * @memberof World
     */
    wires?: WireAttachmentData;
    /**
     * 
     * @type {AcceptsItems}
     * @memberof World
     */
    acceptsItems?: AcceptsItems;
    /**
     * 
     * @type {Array<PotionEffect>}
     * @memberof World
     */
    applicableEffect?: Array<PotionEffect>;
    /**
     * 
     * @type {ArmorSlotType}
     * @memberof World
     */
    armorSlotType?: ArmorSlotType;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    armorType?: CatalogType;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    blastResistance?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    burningFuel?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    damageAbsorption?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    efficiency?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    equipmentType?: CatalogType;
    /**
     * 
     * @type {EquipmentSlotType}
     * @memberof World
     */
    equiptmentSlotType?: EquipmentSlotType;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    eyeHeight?: number;
    /**
     * 
     * @type {Vector3d}
     * @memberof World
     */
    eyeLocation?: Vector3d;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    fluidTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    fluidViscosity?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    foodRestoration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    fullBlockSelectionBox?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    gravityAffected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    groundLuminance?: number;
    /**
     * 
     * @type {GuiIdProperty}
     * @memberof World
     */
    guiId?: GuiIdProperty;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    hardness?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    heldItem?: CatalogType;
    /**
     * 
     * @type {Identifiable}
     * @memberof World
     */
    identifiable?: Identifiable;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    indirectlyPowered?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    instrument?: CatalogType;
    /**
     * 
     * @type {InventoryCapacity}
     * @memberof World
     */
    inventoryCapacity?: InventoryCapacity;
    /**
     * 
     * @type {InventoryDimension}
     * @memberof World
     */
    inventoryDimension?: InventoryDimension;
    /**
     * 
     * @type {InventoryTitle}
     * @memberof World
     */
    inventoryTitle?: InventoryTitle;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    lightEmission?: number;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    matter?: World.MatterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    passable?: boolean;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    record?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    replaceable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    saturationProperty?: number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    skyLuminance?: number;
    /**
     * 
     * @type {SlotIndex}
     * @memberof World
     */
    slotIndex?: SlotIndex;
    /**
     * 
     * @type {SlotPos}
     * @memberof World
     */
    slotPos?: SlotPos;
    /**
     * 
     * @type {SlotSide}
     * @memberof World
     */
    slotSide?: SlotSide;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    smeltable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    solidCube?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    statisticsTracked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    surrogateBlock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    temperature?: number;
    /**
     * 
     * @type {CatalogType}
     * @memberof World
     */
    toolType?: CatalogType;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    unbreakable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    useLimit?: number;
}

/**
 * @export
 * @namespace World
 */
export namespace World {
    /**
     * @export
     * @enum {string}
     */
    export enum AxisEnum {
        X = <any> 'X',
        Y = <any> 'Y',
        Z = <any> 'Z'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectedDirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionEnum {
        NORTH = <any> 'NORTH',
        NORTHNORTHEAST = <any> 'NORTH_NORTHEAST',
        NORTHEAST = <any> 'NORTHEAST',
        EASTNORTHEAST = <any> 'EAST_NORTHEAST',
        EAST = <any> 'EAST',
        EASTSOUTHEAST = <any> 'EAST_SOUTHEAST',
        SOUTHEAST = <any> 'SOUTHEAST',
        SOUTHSOUTHEAST = <any> 'SOUTH_SOUTHEAST',
        SOUTH = <any> 'SOUTH',
        SOUTHSOUTHWEST = <any> 'SOUTH_SOUTHWEST',
        SOUTHWEST = <any> 'SOUTHWEST',
        WESTSOUTHWEST = <any> 'WEST_SOUTHWEST',
        WEST = <any> 'WEST',
        WESTNORTHWEST = <any> 'WEST_NORTHWEST',
        NORTHWEST = <any> 'NORTHWEST',
        NORTHNORTHWEST = <any> 'NORTH_NORTHWEST',
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatterEnum {
        SOLID = <any> 'SOLID',
        LIQUID = <any> 'LIQUID',
        GAS = <any> 'GAS'
    }
}

/**
 * 
 * @export
 * @interface WorldBorder
 */
export interface WorldBorder {
    /**
     * The center of the world border
     * @type {Vector3d}
     * @memberof WorldBorder
     */
    center: Vector3d;
    /**
     * The amount of damage done to players outside the border
     * @type {number}
     * @memberof WorldBorder
     */
    damageAmount: number;
    /**
     * The maximum amount of damage done to a player
     * @type {number}
     * @memberof WorldBorder
     */
    damageThreshold: number;
    /**
     * The diameter of the border
     * @type {number}
     * @memberof WorldBorder
     */
    diameter: number;
    /**
     * The new diameter of the border, in case it is collapsing/expanding
     * @type {number}
     * @memberof WorldBorder
     */
    newDiameter: number;
    /**
     * The time remaining until the border reaches it's new size
     * @type {number}
     * @memberof WorldBorder
     */
    timeRemaining: number;
    /**
     * The amount of distance from the border a player will receive a warning at
     * @type {number}
     * @memberof WorldBorder
     */
    warningDistance: number;
    /**
     * The amount of time near a border before a warning is shown for players
     * @type {number}
     * @memberof WorldBorder
     */
    warningTime: number;
}

/**
 * 
 * @export
 * @interface BlockChangeOperation
 */
export interface BlockChangeOperation extends BlockOperation {
}

/**
 * @export
 * @namespace BlockChangeOperation
 */
export namespace BlockChangeOperation {
}

/**
 * 
 * @export
 * @interface BlockGetOperation
 */
export interface BlockGetOperation extends BlockOperation {
    /**
     * 
     * @type {Array<Array<Array<BlockState>>>}
     * @memberof BlockGetOperation
     */
    blocks?: Array<Array<Array<BlockState>>>;
}

/**
 * @export
 * @namespace BlockGetOperation
 */
export namespace BlockGetOperation {
}

/**
 * 
 * @export
 * @interface ChatMessage
 */
export interface ChatMessage {
    /**
     * The content of the message
     * @type {string}
     * @memberof ChatMessage
     */
    content: string;
    /**
     * The receivers of this message
     * @type {Array<any>}
     * @memberof ChatMessage
     */
    receivers: Array<any>;
    /**
     * The timestamp at which the chat message was sent (epoch millis)
     * @type {number}
     * @memberof ChatMessage
     */
    timestamp: number;
    /**
     * The sender of the message
     * @type {Player}
     * @memberof ChatMessage
     */
    sender: Player;
}


/**
 * ActiveTimeApi - fetch parameter creator
 * @export
 */
export const ActiveTimeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a report for the whole server from week ago until now     **Required permissions:**    - **active-time.report.server**   
         * @summary Server report
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerReport(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/active-time`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a report for a specific user from a week ago until now     **Required permissions:**    - **active-time.report.user**   
         * @summary User report
         * @param {string} uuid 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserReport(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getUserReport.');
            }
            const localVarPath = `/active-time/user/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveTimeApi - functional programming interface
 * @export
 */
export const ActiveTimeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generates a report for the whole server from week ago until now     **Required permissions:**    - **active-time.report.server**   
         * @summary Server report
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerReport(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServerReport> {
            const localVarFetchArgs = ActiveTimeApiFetchParamCreator(configuration).getServerReport(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generates a report for a specific user from a week ago until now     **Required permissions:**    - **active-time.report.user**   
         * @summary User report
         * @param {string} uuid 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserReport(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserReport> {
            const localVarFetchArgs = ActiveTimeApiFetchParamCreator(configuration).getUserReport(uuid, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActiveTimeApi - factory interface
 * @export
 */
export const ActiveTimeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generates a report for the whole server from week ago until now     **Required permissions:**    - **active-time.report.server**   
         * @summary Server report
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerReport(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ActiveTimeApiFp(configuration).getServerReport(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Generates a report for a specific user from a week ago until now     **Required permissions:**    - **active-time.report.user**   
         * @summary User report
         * @param {string} uuid 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserReport(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ActiveTimeApiFp(configuration).getUserReport(uuid, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * ActiveTimeApi - object-oriented interface
 * @export
 * @class ActiveTimeApi
 * @extends {BaseAPI}
 */
export class ActiveTimeApi extends BaseAPI {
    /**
     * Generates a report for the whole server from week ago until now     **Required permissions:**    - **active-time.report.server**   
     * @summary Server report
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveTimeApi
     */
    public getServerReport(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ActiveTimeApiFp(this.configuration).getServerReport(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Generates a report for a specific user from a week ago until now     **Required permissions:**    - **active-time.report.user**   
     * @summary User report
     * @param {string} uuid 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveTimeApi
     */
    public getUserReport(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ActiveTimeApiFp(this.configuration).getUserReport(uuid, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * BlockApi - fetch parameter creator
 * @export
 */
export const BlockApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a request to get or change blocks on the server.     **Required permissions:**    - **block.op.create**   
         * @summary Create a block operation
         * @param {CreateBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockOperation(body?: CreateBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/block/op`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBlockOperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pending or running block operation. **THIS DOES NOT UNDO THE BLOCK CHANGES**     **Required permissions:**    - **block.op.delete**   
         * @summary Stop a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteBlockOperation.');
            }
            const localVarPath = `/block/op/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about one block in the world.     **Required permissions:**    - **block.one**   
         * @summary Get a block
         * @param {string} world The uuid of the world to get the block from
         * @param {number} x The x-coordinate of the block
         * @param {number} y The y-coordinate of the block
         * @param {number} z The z-coordinate of the block
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling getBlock.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling getBlock.');
            }
            // verify required parameter 'y' is not null or undefined
            if (y === null || y === undefined) {
                throw new RequiredError('y','Required parameter y was null or undefined when calling getBlock.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling getBlock.');
            }
            const localVarPath = `/block/{world}/{x}/{y}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details about a specific block operation     **Required permissions:**    - **block.op.one**   
         * @summary Get a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getBlockOperation.');
            }
            const localVarPath = `/block/op/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the currently running block operations.     **Required permissions:**    - **block.op.list**   
         * @summary List block operations
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlockOperations(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/block/op`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing block operation to either pause or continue it.     **Required permissions:**    - **block.op.modify**   
         * @summary Modify a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {ModifyBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBlockOperation(uuid: string, body?: ModifyBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling modifyBlockOperation.');
            }
            const localVarPath = `/block/op/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ModifyBlockOperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Start a request to get or change blocks on the server.     **Required permissions:**    - **block.op.create**   
         * @summary Create a block operation
         * @param {CreateBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockOperation(body?: CreateBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockOperation> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).createBlockOperation(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel a pending or running block operation. **THIS DOES NOT UNDO THE BLOCK CHANGES**     **Required permissions:**    - **block.op.delete**   
         * @summary Stop a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockOperation> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).deleteBlockOperation(uuid, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets information about one block in the world.     **Required permissions:**    - **block.one**   
         * @summary Get a block
         * @param {string} world The uuid of the world to get the block from
         * @param {number} x The x-coordinate of the block
         * @param {number} y The y-coordinate of the block
         * @param {number} z The z-coordinate of the block
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockState> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).getBlock(world, x, y, z, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets details about a specific block operation     **Required permissions:**    - **block.op.one**   
         * @summary Get a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockOperation> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).getBlockOperation(uuid, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of all the currently running block operations.     **Required permissions:**    - **block.op.list**   
         * @summary List block operations
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlockOperations(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BlockOperation>> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).listBlockOperations(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify an existing block operation to either pause or continue it.     **Required permissions:**    - **block.op.modify**   
         * @summary Modify a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {ModifyBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBlockOperation(uuid: string, body?: ModifyBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockOperation> {
            const localVarFetchArgs = BlockApiFetchParamCreator(configuration).modifyBlockOperation(uuid, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Start a request to get or change blocks on the server.     **Required permissions:**    - **block.op.create**   
         * @summary Create a block operation
         * @param {CreateBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockOperation(body?: CreateBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).createBlockOperation(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Cancel a pending or running block operation. **THIS DOES NOT UNDO THE BLOCK CHANGES**     **Required permissions:**    - **block.op.delete**   
         * @summary Stop a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).deleteBlockOperation(uuid, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets information about one block in the world.     **Required permissions:**    - **block.one**   
         * @summary Get a block
         * @param {string} world The uuid of the world to get the block from
         * @param {number} x The x-coordinate of the block
         * @param {number} y The y-coordinate of the block
         * @param {number} z The z-coordinate of the block
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).getBlock(world, x, y, z, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets details about a specific block operation     **Required permissions:**    - **block.op.one**   
         * @summary Get a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).getBlockOperation(uuid, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Returns a list of all the currently running block operations.     **Required permissions:**    - **block.op.list**   
         * @summary List block operations
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlockOperations(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).listBlockOperations(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify an existing block operation to either pause or continue it.     **Required permissions:**    - **block.op.modify**   
         * @summary Modify a block operation
         * @param {string} uuid The uuid of the block operation
         * @param {ModifyBlockOperationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBlockOperation(uuid: string, body?: ModifyBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return BlockApiFp(configuration).modifyBlockOperation(uuid, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     * Start a request to get or change blocks on the server.     **Required permissions:**    - **block.op.create**   
     * @summary Create a block operation
     * @param {CreateBlockOperationRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public createBlockOperation(body?: CreateBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).createBlockOperation(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel a pending or running block operation. **THIS DOES NOT UNDO THE BLOCK CHANGES**     **Required permissions:**    - **block.op.delete**   
     * @summary Stop a block operation
     * @param {string} uuid The uuid of the block operation
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public deleteBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).deleteBlockOperation(uuid, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets information about one block in the world.     **Required permissions:**    - **block.one**   
     * @summary Get a block
     * @param {string} world The uuid of the world to get the block from
     * @param {number} x The x-coordinate of the block
     * @param {number} y The y-coordinate of the block
     * @param {number} z The z-coordinate of the block
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public getBlock(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).getBlock(world, x, y, z, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets details about a specific block operation     **Required permissions:**    - **block.op.one**   
     * @summary Get a block operation
     * @param {string} uuid The uuid of the block operation
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public getBlockOperation(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).getBlockOperation(uuid, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of all the currently running block operations.     **Required permissions:**    - **block.op.list**   
     * @summary List block operations
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public listBlockOperations(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).listBlockOperations(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify an existing block operation to either pause or continue it.     **Required permissions:**    - **block.op.modify**   
     * @summary Modify a block operation
     * @param {string} uuid The uuid of the block operation
     * @param {ModifyBlockOperationRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public modifyBlockOperation(uuid: string, body?: ModifyBlockOperationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return BlockApiFp(this.configuration).modifyBlockOperation(uuid, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * ChunkApi - fetch parameter creator
 * @export
 */
export const ChunkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forces a chunk to be loaded into memory, and created if it does not exist.     **Required permissions:**    - **chunk.create**   
         * @summary Load & Generate a chunk
         * @param {string} world The uuid of the world in which to create the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling createChunkAt.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling createChunkAt.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling createChunkAt.');
            }
            const localVarPath = `/chunk/{world}/{x}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a chunk     **Required permissions:**    - **chunk.one**   
         * @summary Get a chunk
         * @param {string} world The uuid of the world in which to get the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling getChunkAt.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling getChunkAt.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling getChunkAt.');
            }
            const localVarPath = `/chunk/{world}/{x}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the loaded chunks for the specified world.     **Required permissions:**    - **chunk.list**   
         * @summary List chunks
         * @param {string} world The uuid of the for which to get all chunks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChunks(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling listChunks.');
            }
            const localVarPath = `/chunk/{world}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChunkApi - functional programming interface
 * @export
 */
export const ChunkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Forces a chunk to be loaded into memory, and created if it does not exist.     **Required permissions:**    - **chunk.create**   
         * @summary Load & Generate a chunk
         * @param {string} world The uuid of the world in which to create the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Chunk> {
            const localVarFetchArgs = ChunkApiFetchParamCreator(configuration).createChunkAt(world, x, z, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a chunk     **Required permissions:**    - **chunk.one**   
         * @summary Get a chunk
         * @param {string} world The uuid of the world in which to get the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Chunk> {
            const localVarFetchArgs = ChunkApiFetchParamCreator(configuration).getChunkAt(world, x, z, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all the loaded chunks for the specified world.     **Required permissions:**    - **chunk.list**   
         * @summary List chunks
         * @param {string} world The uuid of the for which to get all chunks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChunks(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Chunk>> {
            const localVarFetchArgs = ChunkApiFetchParamCreator(configuration).listChunks(world, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChunkApi - factory interface
 * @export
 */
export const ChunkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Forces a chunk to be loaded into memory, and created if it does not exist.     **Required permissions:**    - **chunk.create**   
         * @summary Load & Generate a chunk
         * @param {string} world The uuid of the world in which to create the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ChunkApiFp(configuration).createChunkAt(world, x, z, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a chunk     **Required permissions:**    - **chunk.one**   
         * @summary Get a chunk
         * @param {string} world The uuid of the world in which to get the chunk
         * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
         * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ChunkApiFp(configuration).getChunkAt(world, x, z, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a list of all the loaded chunks for the specified world.     **Required permissions:**    - **chunk.list**   
         * @summary List chunks
         * @param {string} world The uuid of the for which to get all chunks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChunks(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ChunkApiFp(configuration).listChunks(world, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * ChunkApi - object-oriented interface
 * @export
 * @class ChunkApi
 * @extends {BaseAPI}
 */
export class ChunkApi extends BaseAPI {
    /**
     * Forces a chunk to be loaded into memory, and created if it does not exist.     **Required permissions:**    - **chunk.create**   
     * @summary Load & Generate a chunk
     * @param {string} world The uuid of the world in which to create the chunk
     * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
     * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public createChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ChunkApiFp(this.configuration).createChunkAt(world, x, z, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a chunk     **Required permissions:**    - **chunk.one**   
     * @summary Get a chunk
     * @param {string} world The uuid of the world in which to get the chunk
     * @param {number} x The x-coordinate of the chunk (in chunk coordinates)
     * @param {number} z The z-coordinate of the chunk (in chunk coordinates)
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public getChunkAt(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ChunkApiFp(this.configuration).getChunkAt(world, x, z, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all the loaded chunks for the specified world.     **Required permissions:**    - **chunk.list**   
     * @summary List chunks
     * @param {string} world The uuid of the for which to get all chunks
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChunkApi
     */
    public listChunks(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ChunkApiFp(this.configuration).listChunks(world, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * CmdSchedulerApi - fetch parameter creator
 * @export
 */
export const CmdSchedulerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a task.     **Required permissions:**    - **cmd-scheduler.delete**   
         * @summary Delete a task
         * @param {string} name The name of the task
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/cmd-scheduler/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the registered tasks.     **Required permissions:**    - **cmd-scheduler.list**   
         * @summary List tasks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/cmd-scheduler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CmdSchedulerApi - functional programming interface
 * @export
 */
export const CmdSchedulerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a task.     **Required permissions:**    - **cmd-scheduler.delete**   
         * @summary Delete a task
         * @param {string} name The name of the task
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommandTask> {
            const localVarFetchArgs = CmdSchedulerApiFetchParamCreator(configuration).deleteTask(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all the registered tasks.     **Required permissions:**    - **cmd-scheduler.list**   
         * @summary List tasks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CommandTask>> {
            const localVarFetchArgs = CmdSchedulerApiFetchParamCreator(configuration).listTasks(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CmdSchedulerApi - factory interface
 * @export
 */
export const CmdSchedulerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a task.     **Required permissions:**    - **cmd-scheduler.delete**   
         * @summary Delete a task
         * @param {string} name The name of the task
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return CmdSchedulerApiFp(configuration).deleteTask(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a list of all the registered tasks.     **Required permissions:**    - **cmd-scheduler.list**   
         * @summary List tasks
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return CmdSchedulerApiFp(configuration).listTasks(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * CmdSchedulerApi - object-oriented interface
 * @export
 * @class CmdSchedulerApi
 * @extends {BaseAPI}
 */
export class CmdSchedulerApi extends BaseAPI {
    /**
     * Deletes a task.     **Required permissions:**    - **cmd-scheduler.delete**   
     * @summary Delete a task
     * @param {string} name The name of the task
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmdSchedulerApi
     */
    public deleteTask(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return CmdSchedulerApiFp(this.configuration).deleteTask(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all the registered tasks.     **Required permissions:**    - **cmd-scheduler.list**   
     * @summary List tasks
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmdSchedulerApi
     */
    public listTasks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return CmdSchedulerApiFp(this.configuration).listTasks(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * CommandApi - fetch parameter creator
 * @export
 */
export const CommandApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a command.     **Required permissions:**    - **cmd.one**   
         * @summary Get a command
         * @param {string} cmd The id of the command
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(cmd: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling getCommand.');
            }
            const localVarPath = `/cmd/{cmd}`
                .replace(`{${"cmd"}}`, encodeURIComponent(String(cmd)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the commands available on the server.     **Required permissions:**    - **cmd.list**   
         * @summary List commands
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/cmd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a command on the server. (Almost the same as running it from the console).   Pass an array of commands to execute them in succession, you can also just pass a list with only one command if that's all you want to execute.  Returns a list with each response corresponding to a command.     **Required permissions:**    - **cmd.run**   - **cmd.run.[command]**   
         * @summary Execute a command
         * @param {Array<ExecuteCommandRequest>} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCommands(body?: Array<ExecuteCommandRequest>, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/cmd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ExecuteCommandRequest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandApi - functional programming interface
 * @export
 */
export const CommandApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a command.     **Required permissions:**    - **cmd.one**   
         * @summary Get a command
         * @param {string} cmd The id of the command
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(cmd: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Command> {
            const localVarFetchArgs = CommandApiFetchParamCreator(configuration).getCommand(cmd, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all the commands available on the server.     **Required permissions:**    - **cmd.list**   
         * @summary List commands
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Command>> {
            const localVarFetchArgs = CommandApiFetchParamCreator(configuration).listCommands(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute a command on the server. (Almost the same as running it from the console).   Pass an array of commands to execute them in succession, you can also just pass a list with only one command if that's all you want to execute.  Returns a list with each response corresponding to a command.     **Required permissions:**    - **cmd.run**   - **cmd.run.[command]**   
         * @summary Execute a command
         * @param {Array<ExecuteCommandRequest>} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCommands(body?: Array<ExecuteCommandRequest>, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExecuteCommandResponse>> {
            const localVarFetchArgs = CommandApiFetchParamCreator(configuration).runCommands(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommandApi - factory interface
 * @export
 */
export const CommandApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get detailed information about a command.     **Required permissions:**    - **cmd.one**   
         * @summary Get a command
         * @param {string} cmd The id of the command
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(cmd: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return CommandApiFp(configuration).getCommand(cmd, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a list of all the commands available on the server.     **Required permissions:**    - **cmd.list**   
         * @summary List commands
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return CommandApiFp(configuration).listCommands(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Execute a command on the server. (Almost the same as running it from the console).   Pass an array of commands to execute them in succession, you can also just pass a list with only one command if that's all you want to execute.  Returns a list with each response corresponding to a command.     **Required permissions:**    - **cmd.run**   - **cmd.run.[command]**   
         * @summary Execute a command
         * @param {Array<ExecuteCommandRequest>} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCommands(body?: Array<ExecuteCommandRequest>, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return CommandApiFp(configuration).runCommands(body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * CommandApi - object-oriented interface
 * @export
 * @class CommandApi
 * @extends {BaseAPI}
 */
export class CommandApi extends BaseAPI {
    /**
     * Get detailed information about a command.     **Required permissions:**    - **cmd.one**   
     * @summary Get a command
     * @param {string} cmd The id of the command
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public getCommand(cmd: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return CommandApiFp(this.configuration).getCommand(cmd, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all the commands available on the server.     **Required permissions:**    - **cmd.list**   
     * @summary List commands
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public listCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return CommandApiFp(this.configuration).listCommands(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Execute a command on the server. (Almost the same as running it from the console).   Pass an array of commands to execute them in succession, you can also just pass a list with only one command if that's all you want to execute.  Returns a list with each response corresponding to a command.     **Required permissions:**    - **cmd.run**   - **cmd.run.[command]**   
     * @summary Execute a command
     * @param {Array<ExecuteCommandRequest>} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public runCommands(body?: Array<ExecuteCommandRequest>, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return CommandApiFp(this.configuration).runCommands(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * EconomyApi - fetch parameter creator
 * @export
 */
export const EconomyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.account.one**   
         * @summary List currencies
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAccount.');
            }
            const localVarPath = `/economy/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.currency.list**   
         * @summary List currencies
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/economy/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EconomyApi - functional programming interface
 * @export
 */
export const EconomyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.account.one**   
         * @summary List currencies
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getAccount(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.currency.list**   
         * @summary List currencies
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Currency>> {
            const localVarFetchArgs = EconomyApiFetchParamCreator(configuration).getCurrencies(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EconomyApi - factory interface
 * @export
 */
export const EconomyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.account.one**   
         * @summary List currencies
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EconomyApiFp(configuration).getAccount(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.currency.list**   
         * @summary List currencies
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EconomyApiFp(configuration).getCurrencies(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * EconomyApi - object-oriented interface
 * @export
 * @class EconomyApi
 * @extends {BaseAPI}
 */
export class EconomyApi extends BaseAPI {
    /**
     * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.account.one**   
     * @summary List currencies
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getAccount(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EconomyApiFp(this.configuration).getAccount(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all the currencies that the current economy supports.     **Required permissions:**    - **economy.currency.list**   
     * @summary List currencies
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getCurrencies(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EconomyApiFp(this.configuration).getCurrencies(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * EntityApi - fetch parameter creator
 * @export
 */
export const EntityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates & Spawns a new entity with the specified properties.     **Required permissions:**    - **entity.create**   
         * @summary Spawn an entity
         * @param {CreateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(body?: CreateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/entity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateEntityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides direct access to the underlaying entity object and can execute any method on it.     **Required permissions:**    - **entity.method**   
         * @summary Execute a method
         * @param {string} entity The uuid of the entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(entity: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling executeMethod.');
            }
            const localVarPath = `/entity/{entity}/method`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteMethodRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about an entity.     **Required permissions:**    - **entity.one**   
         * @summary Get entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling getEntity.');
            }
            const localVarPath = `/entity/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all entities on the server (in all worlds).     **Required permissions:**    - **entity.list**   
         * @summary List entities
         * @param {string} [world] The world to filter the entities by
         * @param {string} [type] The type id of the entities to filter by
         * @param {string} [min] The minimum coordinates at which the entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/entity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (world !== undefined) {
                localVarQueryParameter['world'] = world;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of an existing entity.     **Required permissions:**    - **entity.modify**   
         * @summary Modify an entity
         * @param {string} entity The uuid of the entity
         * @param {UpdateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntity(entity: string, body?: UpdateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling modifyEntity.');
            }
            const localVarPath = `/entity/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateEntityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroys an entity.     **Required permissions:**    - **entity.delete**   
         * @summary Destroy an entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling removeEntity.');
            }
            const localVarPath = `/entity/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates & Spawns a new entity with the specified properties.     **Required permissions:**    - **entity.create**   
         * @summary Spawn an entity
         * @param {CreateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(body?: CreateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entity> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).createEntity(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Provides direct access to the underlaying entity object and can execute any method on it.     **Required permissions:**    - **entity.method**   
         * @summary Execute a method
         * @param {string} entity The uuid of the entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(entity: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecuteMethodResponse> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).executeMethod(entity, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about an entity.     **Required permissions:**    - **entity.one**   
         * @summary Get entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entity> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).getEntity(entity, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all entities on the server (in all worlds).     **Required permissions:**    - **entity.list**   
         * @summary List entities
         * @param {string} [world] The world to filter the entities by
         * @param {string} [type] The type id of the entities to filter by
         * @param {string} [min] The minimum coordinates at which the entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Entity>> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).listEntities(world, type, min, max, limit, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify the properties of an existing entity.     **Required permissions:**    - **entity.modify**   
         * @summary Modify an entity
         * @param {string} entity The uuid of the entity
         * @param {UpdateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntity(entity: string, body?: UpdateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entity> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).modifyEntity(entity, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Destroys an entity.     **Required permissions:**    - **entity.delete**   
         * @summary Destroy an entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Entity> {
            const localVarFetchArgs = EntityApiFetchParamCreator(configuration).removeEntity(entity, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates & Spawns a new entity with the specified properties.     **Required permissions:**    - **entity.create**   
         * @summary Spawn an entity
         * @param {CreateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(body?: CreateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).createEntity(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Provides direct access to the underlaying entity object and can execute any method on it.     **Required permissions:**    - **entity.method**   
         * @summary Execute a method
         * @param {string} entity The uuid of the entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(entity: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).executeMethod(entity, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about an entity.     **Required permissions:**    - **entity.one**   
         * @summary Get entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).getEntity(entity, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all entities on the server (in all worlds).     **Required permissions:**    - **entity.list**   
         * @summary List entities
         * @param {string} [world] The world to filter the entities by
         * @param {string} [type] The type id of the entities to filter by
         * @param {string} [min] The minimum coordinates at which the entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).listEntities(world, type, min, max, limit, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify the properties of an existing entity.     **Required permissions:**    - **entity.modify**   
         * @summary Modify an entity
         * @param {string} entity The uuid of the entity
         * @param {UpdateEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntity(entity: string, body?: UpdateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).modifyEntity(entity, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Destroys an entity.     **Required permissions:**    - **entity.delete**   
         * @summary Destroy an entity
         * @param {string} entity The uuid of the entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return EntityApiFp(configuration).removeEntity(entity, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI {
    /**
     * Creates & Spawns a new entity with the specified properties.     **Required permissions:**    - **entity.create**   
     * @summary Spawn an entity
     * @param {CreateEntityRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public createEntity(body?: CreateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).createEntity(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Provides direct access to the underlaying entity object and can execute any method on it.     **Required permissions:**    - **entity.method**   
     * @summary Execute a method
     * @param {string} entity The uuid of the entity
     * @param {ExecuteMethodRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public executeMethod(entity: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).executeMethod(entity, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about an entity.     **Required permissions:**    - **entity.one**   
     * @summary Get entity
     * @param {string} entity The uuid of the entity
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).getEntity(entity, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all entities on the server (in all worlds).     **Required permissions:**    - **entity.list**   
     * @summary List entities
     * @param {string} [world] The world to filter the entities by
     * @param {string} [type] The type id of the entities to filter by
     * @param {string} [min] The minimum coordinates at which the entity must be, min&#x3D;x|y|z
     * @param {string} [max] The maximum coordinates at which the entity must be, max&#x3D;x|y|z
     * @param {number} [limit] The maximum amount of entities returned
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public listEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).listEntities(world, type, min, max, limit, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify the properties of an existing entity.     **Required permissions:**    - **entity.modify**   
     * @summary Modify an entity
     * @param {string} entity The uuid of the entity
     * @param {UpdateEntityRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public modifyEntity(entity: string, body?: UpdateEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).modifyEntity(entity, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Destroys an entity.     **Required permissions:**    - **entity.delete**   
     * @summary Destroy an entity
     * @param {string} entity The uuid of the entity
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public removeEntity(entity: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return EntityApiFp(this.configuration).removeEntity(entity, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * GWMCratesApi - fetch parameter creator
 * @export
 */
export const GWMCratesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all the managers on the server.     **Required permissions:**    - **gwm-crates.manager.list**   
         * @summary List managers
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrates(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/gwm-crates/manager`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GWMCratesApi - functional programming interface
 * @export
 */
export const GWMCratesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of all the managers on the server.     **Required permissions:**    - **gwm-crates.manager.list**   
         * @summary List managers
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrates(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CachedObject>> {
            const localVarFetchArgs = GWMCratesApiFetchParamCreator(configuration).listCrates(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GWMCratesApi - factory interface
 * @export
 */
export const GWMCratesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of all the managers on the server.     **Required permissions:**    - **gwm-crates.manager.list**   
         * @summary List managers
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrates(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return GWMCratesApiFp(configuration).listCrates(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * GWMCratesApi - object-oriented interface
 * @export
 * @class GWMCratesApi
 * @extends {BaseAPI}
 */
export class GWMCratesApi extends BaseAPI {
    /**
     * Get a list of all the managers on the server.     **Required permissions:**    - **gwm-crates.manager.list**   
     * @summary List managers
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GWMCratesApi
     */
    public listCrates(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return GWMCratesApiFp(this.configuration).listCrates(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * HistoryApi - fetch parameter creator
 * @export
 */
export const HistoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View a history of the server messages.     **Required permissions:**    - **history.message**   
         * @summary Get message history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/history/message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View a history of the server commands.     **Required permissions:**    - **history.cmd**   
         * @summary Get command history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/history/cmd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * View a history of the server messages.     **Required permissions:**    - **history.message**   
         * @summary Get message history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Message>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getChat(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View a history of the server commands.     **Required permissions:**    - **history.cmd**   
         * @summary Get command history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CommandCall>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getCommands(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * View a history of the server messages.     **Required permissions:**    - **history.message**   
         * @summary Get message history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChat(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return HistoryApiFp(configuration).getChat(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * View a history of the server commands.     **Required permissions:**    - **history.cmd**   
         * @summary Get command history
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return HistoryApiFp(configuration).getCommands(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     * View a history of the server messages.     **Required permissions:**    - **history.message**   
     * @summary Get message history
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getChat(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return HistoryApiFp(this.configuration).getChat(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * View a history of the server commands.     **Required permissions:**    - **history.cmd**   
     * @summary Get command history
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getCommands(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return HistoryApiFp(this.configuration).getCommands(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * InfoApi - fetch parameter creator
 * @export
 */
export const InfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get general information about the Minecraft server.     **Required permissions:**    - **info.info**   
         * @summary Server info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistical information about the server, such as player count, cpu and memory usage over time.     **Required permissions:**    - **info.stats**   
         * @summary Server stats
         * @param {number} [limit] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/info/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the active servlets running in the Web-API     **Required permissions:**    - **info.servlets**   
         * @summary List servlets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServlets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/info/servlets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get general information about the Minecraft server.     **Required permissions:**    - **info.info**   
         * @summary Server info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServerInfo> {
            const localVarFetchArgs = InfoApiFetchParamCreator(configuration).getInfo(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get statistical information about the server, such as player count, cpu and memory usage over time.     **Required permissions:**    - **info.stats**   
         * @summary Server stats
         * @param {number} [limit] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServerStats> {
            const localVarFetchArgs = InfoApiFetchParamCreator(configuration).getStats(limit, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all the active servlets running in the Web-API     **Required permissions:**    - **info.servlets**   
         * @summary List servlets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServlets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = InfoApiFetchParamCreator(configuration).listServlets(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get general information about the Minecraft server.     **Required permissions:**    - **info.info**   
         * @summary Server info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InfoApiFp(configuration).getInfo(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get statistical information about the server, such as player count, cpu and memory usage over time.     **Required permissions:**    - **info.stats**   
         * @summary Server stats
         * @param {number} [limit] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InfoApiFp(configuration).getStats(limit, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Lists all the active servlets running in the Web-API     **Required permissions:**    - **info.servlets**   
         * @summary List servlets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServlets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InfoApiFp(configuration).listServlets(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Get general information about the Minecraft server.     **Required permissions:**    - **info.info**   
     * @summary Server info
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getInfo(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InfoApiFp(this.configuration).getInfo(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get statistical information about the server, such as player count, cpu and memory usage over time.     **Required permissions:**    - **info.stats**   
     * @summary Server stats
     * @param {number} [limit] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getStats(limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InfoApiFp(this.configuration).getStats(limit, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all the active servlets running in the Web-API     **Required permissions:**    - **info.servlets**   
     * @summary List servlets
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public listServlets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InfoApiFp(this.configuration).listServlets(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * InteractiveMessageApi - fetch parameter creator
 * @export
 */
export const InteractiveMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a message.     **Required permissions:**    - **interactive-message.one**   
         * @summary Get a message
         * @param {string} uuid The uuid of the sent message
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getMessage.');
            }
            const localVarPath = `/interactive-message/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the messages that were sent through the message endpoint since the server started.     **Required permissions:**    - **interactive-message.list**   
         * @summary List messages
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/interactive-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an interactive message to a player. Make sure to have an event hook for \"custom_message\" to receive the response.     **Required permissions:**    - **interactive-message.create**   
         * @summary Send a message
         * @param {InteractiveMessage} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body?: InteractiveMessage, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/interactive-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InteractiveMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteractiveMessageApi - functional programming interface
 * @export
 */
export const InteractiveMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a message.     **Required permissions:**    - **interactive-message.one**   
         * @summary Get a message
         * @param {string} uuid The uuid of the sent message
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InteractiveMessage> {
            const localVarFetchArgs = InteractiveMessageApiFetchParamCreator(configuration).getMessage(uuid, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the messages that were sent through the message endpoint since the server started.     **Required permissions:**    - **interactive-message.list**   
         * @summary List messages
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InteractiveMessage>> {
            const localVarFetchArgs = InteractiveMessageApiFetchParamCreator(configuration).listMessages(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an interactive message to a player. Make sure to have an event hook for \"custom_message\" to receive the response.     **Required permissions:**    - **interactive-message.create**   
         * @summary Send a message
         * @param {InteractiveMessage} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body?: InteractiveMessage, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InteractiveMessage> {
            const localVarFetchArgs = InteractiveMessageApiFetchParamCreator(configuration).sendMessage(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InteractiveMessageApi - factory interface
 * @export
 */
export const InteractiveMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get detailed information about a message.     **Required permissions:**    - **interactive-message.one**   
         * @summary Get a message
         * @param {string} uuid The uuid of the sent message
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InteractiveMessageApiFp(configuration).getMessage(uuid, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the messages that were sent through the message endpoint since the server started.     **Required permissions:**    - **interactive-message.list**   
         * @summary List messages
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InteractiveMessageApiFp(configuration).listMessages(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Send an interactive message to a player. Make sure to have an event hook for \"custom_message\" to receive the response.     **Required permissions:**    - **interactive-message.create**   
         * @summary Send a message
         * @param {InteractiveMessage} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body?: InteractiveMessage, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return InteractiveMessageApiFp(configuration).sendMessage(body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * InteractiveMessageApi - object-oriented interface
 * @export
 * @class InteractiveMessageApi
 * @extends {BaseAPI}
 */
export class InteractiveMessageApi extends BaseAPI {
    /**
     * Get detailed information about a message.     **Required permissions:**    - **interactive-message.one**   
     * @summary Get a message
     * @param {string} uuid The uuid of the sent message
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractiveMessageApi
     */
    public getMessage(uuid: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InteractiveMessageApiFp(this.configuration).getMessage(uuid, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the messages that were sent through the message endpoint since the server started.     **Required permissions:**    - **interactive-message.list**   
     * @summary List messages
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractiveMessageApi
     */
    public listMessages(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InteractiveMessageApiFp(this.configuration).listMessages(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Send an interactive message to a player. Make sure to have an event hook for \"custom_message\" to receive the response.     **Required permissions:**    - **interactive-message.create**   
     * @summary Send a message
     * @param {InteractiveMessage} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractiveMessageApi
     */
    public sendMessage(body?: InteractiveMessage, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return InteractiveMessageApiFp(this.configuration).sendMessage(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * MMCRestrictApi - fetch parameter creator
 * @export
 */
export const MMCRestrictApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new item to the restricted item list.     **Required permissions:**    - **mmc-restrict.item.create**   
         * @summary Add an item
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItem(body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/mmc-restrict/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MMCRestrictItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.delete**   
         * @summary Delete an item
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/mmc-restrict/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of restricted items on the server.     **Required permissions:**    - **mmc-restrict.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/mmc-restrict/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.modify**   
         * @summary Modify an item
         * @param {string} id 
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyItem(id: string, body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyItem.');
            }
            const localVarPath = `/mmc-restrict/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MMCRestrictItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MMCRestrictApi - functional programming interface
 * @export
 */
export const MMCRestrictApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new item to the restricted item list.     **Required permissions:**    - **mmc-restrict.item.create**   
         * @summary Add an item
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItem(body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MMCRestrictItem> {
            const localVarFetchArgs = MMCRestrictApiFetchParamCreator(configuration).addItem(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.delete**   
         * @summary Delete an item
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MMCRestrictItem> {
            const localVarFetchArgs = MMCRestrictApiFetchParamCreator(configuration).deleteItem(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the list of restricted items on the server.     **Required permissions:**    - **mmc-restrict.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MMCRestrictItem>> {
            const localVarFetchArgs = MMCRestrictApiFetchParamCreator(configuration).listItems(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.modify**   
         * @summary Modify an item
         * @param {string} id 
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyItem(id: string, body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MMCRestrictItem> {
            const localVarFetchArgs = MMCRestrictApiFetchParamCreator(configuration).modifyItem(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MMCRestrictApi - factory interface
 * @export
 */
export const MMCRestrictApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new item to the restricted item list.     **Required permissions:**    - **mmc-restrict.item.create**   
         * @summary Add an item
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItem(body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCRestrictApiFp(configuration).addItem(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Delete an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.delete**   
         * @summary Delete an item
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCRestrictApiFp(configuration).deleteItem(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets the list of restricted items on the server.     **Required permissions:**    - **mmc-restrict.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCRestrictApiFp(configuration).listItems(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.modify**   
         * @summary Modify an item
         * @param {string} id 
         * @param {MMCRestrictItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyItem(id: string, body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCRestrictApiFp(configuration).modifyItem(id, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * MMCRestrictApi - object-oriented interface
 * @export
 * @class MMCRestrictApi
 * @extends {BaseAPI}
 */
export class MMCRestrictApi extends BaseAPI {
    /**
     * Adds a new item to the restricted item list.     **Required permissions:**    - **mmc-restrict.item.create**   
     * @summary Add an item
     * @param {MMCRestrictItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCRestrictApi
     */
    public addItem(body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCRestrictApiFp(this.configuration).addItem(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.delete**   
     * @summary Delete an item
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCRestrictApi
     */
    public deleteItem(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCRestrictApiFp(this.configuration).deleteItem(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the list of restricted items on the server.     **Required permissions:**    - **mmc-restrict.item.list**   
     * @summary List items
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCRestrictApi
     */
    public listItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCRestrictApiFp(this.configuration).listItems(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify an existing restricted item.     **Required permissions:**    - **mmc-restrict.item.modify**   
     * @summary Modify an item
     * @param {string} id 
     * @param {MMCRestrictItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCRestrictApi
     */
    public modifyItem(id: string, body?: MMCRestrictItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCRestrictApiFp(this.configuration).modifyItem(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * MMCTicketsApi - fetch parameter creator
 * @export
 */
export const MMCTicketsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a ticket.     **Required permissions:**    - **mmc-tickets.ticket.one**   
         * @summary Get a ticket
         * @param {number} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(id: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTicket.');
            }
            const localVarPath = `/mmc-tickets/ticket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the tickets on the server.     **Required permissions:**    - **mmc-tickets.ticket.list**   
         * @summary List tickets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/mmc-tickets/ticket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of an existing ticket.     **Required permissions:**    - **mmc-tickets.ticket.modify**   
         * @summary Modify a ticket
         * @param {number} id 
         * @param {MMCTicketsTicket} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTicket(id: number, body?: MMCTicketsTicket, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyTicket.');
            }
            const localVarPath = `/mmc-tickets/ticket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MMCTicketsTicket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MMCTicketsApi - functional programming interface
 * @export
 */
export const MMCTicketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a ticket.     **Required permissions:**    - **mmc-tickets.ticket.one**   
         * @summary Get a ticket
         * @param {number} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(id: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MMCTicketsTicket> {
            const localVarFetchArgs = MMCTicketsApiFetchParamCreator(configuration).getTicket(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the tickets on the server.     **Required permissions:**    - **mmc-tickets.ticket.list**   
         * @summary List tickets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MMCTicketsTicket>> {
            const localVarFetchArgs = MMCTicketsApiFetchParamCreator(configuration).listTickets(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify the properties of an existing ticket.     **Required permissions:**    - **mmc-tickets.ticket.modify**   
         * @summary Modify a ticket
         * @param {number} id 
         * @param {MMCTicketsTicket} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTicket(id: number, body?: MMCTicketsTicket, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MMCTicketsTicket> {
            const localVarFetchArgs = MMCTicketsApiFetchParamCreator(configuration).modifyTicket(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MMCTicketsApi - factory interface
 * @export
 */
export const MMCTicketsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get detailed information about a ticket.     **Required permissions:**    - **mmc-tickets.ticket.one**   
         * @summary Get a ticket
         * @param {number} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(id: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCTicketsApiFp(configuration).getTicket(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the tickets on the server.     **Required permissions:**    - **mmc-tickets.ticket.list**   
         * @summary List tickets
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCTicketsApiFp(configuration).listTickets(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify the properties of an existing ticket.     **Required permissions:**    - **mmc-tickets.ticket.modify**   
         * @summary Modify a ticket
         * @param {number} id 
         * @param {MMCTicketsTicket} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTicket(id: number, body?: MMCTicketsTicket, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MMCTicketsApiFp(configuration).modifyTicket(id, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * MMCTicketsApi - object-oriented interface
 * @export
 * @class MMCTicketsApi
 * @extends {BaseAPI}
 */
export class MMCTicketsApi extends BaseAPI {
    /**
     * Get detailed information about a ticket.     **Required permissions:**    - **mmc-tickets.ticket.one**   
     * @summary Get a ticket
     * @param {number} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCTicketsApi
     */
    public getTicket(id: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCTicketsApiFp(this.configuration).getTicket(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the tickets on the server.     **Required permissions:**    - **mmc-tickets.ticket.list**   
     * @summary List tickets
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCTicketsApi
     */
    public listTickets(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCTicketsApiFp(this.configuration).listTickets(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify the properties of an existing ticket.     **Required permissions:**    - **mmc-tickets.ticket.modify**   
     * @summary Modify a ticket
     * @param {number} id 
     * @param {MMCTicketsTicket} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMCTicketsApi
     */
    public modifyTicket(id: number, body?: MMCTicketsTicket, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MMCTicketsApiFp(this.configuration).modifyTicket(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * MapApi - fetch parameter creator
 * @export
 */
export const MapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an image representing the biomes of the blocks within the specified tile     **Required permissions:**    - **map.map**   
         * @summary Get a map tile
         * @param {string} world The world to get the map tile from
         * @param {number} x The x-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {number} z The z-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMap(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling getMap.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling getMap.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling getMap.');
            }
            const localVarPath = `/map/{world}/{x}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MapApi - functional programming interface
 * @export
 */
export const MapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an image representing the biomes of the blocks within the specified tile     **Required permissions:**    - **map.map**   
         * @summary Get a map tile
         * @param {string} world The world to get the map tile from
         * @param {number} x The x-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {number} z The z-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMap(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MapApiFetchParamCreator(configuration).getMap(world, x, z, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MapApi - factory interface
 * @export
 */
export const MapApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns an image representing the biomes of the blocks within the specified tile     **Required permissions:**    - **map.map**   
         * @summary Get a map tile
         * @param {string} world The world to get the map tile from
         * @param {number} x The x-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {number} z The z-coordinate of the tile (is multiplied by the TILE_SIZE)
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMap(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return MapApiFp(configuration).getMap(world, x, z, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * MapApi - object-oriented interface
 * @export
 * @class MapApi
 * @extends {BaseAPI}
 */
export class MapApi extends BaseAPI {
    /**
     * Returns an image representing the biomes of the blocks within the specified tile     **Required permissions:**    - **map.map**   
     * @summary Get a map tile
     * @param {string} world The world to get the map tile from
     * @param {number} x The x-coordinate of the tile (is multiplied by the TILE_SIZE)
     * @param {number} z The z-coordinate of the tile (is multiplied by the TILE_SIZE)
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapApi
     */
    public getMap(world: string, x: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return MapApiFp(this.configuration).getMap(world, x, z, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * NucleusApi - fetch parameter creator
 * @export
 */
export const NucleusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new jail.     **Required permissions:**    - **nucleus.jail.create**   
         * @summary Create a jail
         * @param {NucleusNamedLocation} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJail(body?: NucleusNamedLocation, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/jail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NucleusNamedLocation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new kit.     **Required permissions:**    - **nucleus.kit.create**   
         * @summary Create a kit
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKit(body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/kit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NucleusKit" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing jail.     **Required permissions:**    - **nucleus.jail.delete**   
         * @summary Delete a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteJail.');
            }
            const localVarPath = `/nucleus/jail/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing kit.     **Required permissions:**    - **nucleus.kit.delete**   
         * @summary Delete a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteKit.');
            }
            const localVarPath = `/nucleus/kit/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a jail.     **Required permissions:**    - **nucleus.jail.one**   
         * @summary Get a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getJail.');
            }
            const localVarPath = `/nucleus/jail/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a kit.     **Required permissions:**    - **nucleus.kit.one**   
         * @summary Get a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getKit.');
            }
            const localVarPath = `/nucleus/kit/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the homes of a player.     **Required permissions:**    - **nucleus.home.list**   
         * @summary List homes
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHomes(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling listHomes.');
            }
            const localVarPath = `/nucleus/home/{player}`
                .replace(`{${"player"}}`, encodeURIComponent(String(player)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the jails on the server.     **Required permissions:**    - **nucleus.jail.list**   
         * @summary List jails
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJails(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/jail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the kits on the server.     **Required permissions:**    - **nucleus.kit.list**   
         * @summary List kits
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKits(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/kit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all mail messages of a player.     **Required permissions:**    - **nucleus.mail.list**   
         * @summary List mail
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling listMail.');
            }
            const localVarPath = `/nucleus/mail/{player}`
                .replace(`{${"player"}}`, encodeURIComponent(String(player)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of loaded Nucleus modules.     **Required permissions:**    - **nucleus.module.list**   
         * @summary List modules
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail_1(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/module`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing jail.     **Required permissions:**    - **nucleus.jail.modify**   
         * @summary Modify a jail
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyJail(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/nucleus/jail/{name}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing kit.     **Required permissions:**    - **nucleus.kit.modify**   
         * @summary Modify a kit
         * @param {string} name 
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyKit(name: string, body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling modifyKit.');
            }
            const localVarPath = `/nucleus/kit/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NucleusKit" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NucleusApi - functional programming interface
 * @export
 */
export const NucleusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new jail.     **Required permissions:**    - **nucleus.jail.create**   
         * @summary Create a jail
         * @param {NucleusNamedLocation} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJail(body?: NucleusNamedLocation, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusNamedLocation> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).createJail(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new kit.     **Required permissions:**    - **nucleus.kit.create**   
         * @summary Create a kit
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKit(body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusKit> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).createKit(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing jail.     **Required permissions:**    - **nucleus.jail.delete**   
         * @summary Delete a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusNamedLocation> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).deleteJail(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing kit.     **Required permissions:**    - **nucleus.kit.delete**   
         * @summary Delete a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusKit> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).deleteKit(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a jail.     **Required permissions:**    - **nucleus.jail.one**   
         * @summary Get a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusNamedLocation> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).getJail(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a kit.     **Required permissions:**    - **nucleus.kit.one**   
         * @summary Get a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusKit> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).getKit(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the homes of a player.     **Required permissions:**    - **nucleus.home.list**   
         * @summary List homes
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHomes(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NucleusNamedLocation>> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).listHomes(player, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the jails on the server.     **Required permissions:**    - **nucleus.jail.list**   
         * @summary List jails
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJails(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NucleusNamedLocation>> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).listJails(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the kits on the server.     **Required permissions:**    - **nucleus.kit.list**   
         * @summary List kits
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKits(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NucleusKit>> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).listKits(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all mail messages of a player.     **Required permissions:**    - **nucleus.mail.list**   
         * @summary List mail
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NucleusMailMessage>> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).listMail(player, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of loaded Nucleus modules.     **Required permissions:**    - **nucleus.module.list**   
         * @summary List modules
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail_1(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).listMail_1(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify an existing jail.     **Required permissions:**    - **nucleus.jail.modify**   
         * @summary Modify a jail
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyJail(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusNamedLocation> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).modifyJail(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify an existing kit.     **Required permissions:**    - **nucleus.kit.modify**   
         * @summary Modify a kit
         * @param {string} name 
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyKit(name: string, body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NucleusKit> {
            const localVarFetchArgs = NucleusApiFetchParamCreator(configuration).modifyKit(name, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NucleusApi - factory interface
 * @export
 */
export const NucleusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new jail.     **Required permissions:**    - **nucleus.jail.create**   
         * @summary Create a jail
         * @param {NucleusNamedLocation} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJail(body?: NucleusNamedLocation, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).createJail(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Creates a new kit.     **Required permissions:**    - **nucleus.kit.create**   
         * @summary Create a kit
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKit(body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).createKit(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Delete an existing jail.     **Required permissions:**    - **nucleus.jail.delete**   
         * @summary Delete a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).deleteJail(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Delete an existing kit.     **Required permissions:**    - **nucleus.kit.delete**   
         * @summary Delete a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).deleteKit(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a jail.     **Required permissions:**    - **nucleus.jail.one**   
         * @summary Get a jail
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).getJail(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a kit.     **Required permissions:**    - **nucleus.kit.one**   
         * @summary Get a kit
         * @param {string} name 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).getKit(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the homes of a player.     **Required permissions:**    - **nucleus.home.list**   
         * @summary List homes
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHomes(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).listHomes(player, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the jails on the server.     **Required permissions:**    - **nucleus.jail.list**   
         * @summary List jails
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJails(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).listJails(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the kits on the server.     **Required permissions:**    - **nucleus.kit.list**   
         * @summary List kits
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKits(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).listKits(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all mail messages of a player.     **Required permissions:**    - **nucleus.mail.list**   
         * @summary List mail
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).listMail(player, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of loaded Nucleus modules.     **Required permissions:**    - **nucleus.module.list**   
         * @summary List modules
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMail_1(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).listMail_1(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify an existing jail.     **Required permissions:**    - **nucleus.jail.modify**   
         * @summary Modify a jail
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyJail(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).modifyJail(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify an existing kit.     **Required permissions:**    - **nucleus.kit.modify**   
         * @summary Modify a kit
         * @param {string} name 
         * @param {NucleusKit} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyKit(name: string, body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return NucleusApiFp(configuration).modifyKit(name, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * NucleusApi - object-oriented interface
 * @export
 * @class NucleusApi
 * @extends {BaseAPI}
 */
export class NucleusApi extends BaseAPI {
    /**
     * Creates a new jail.     **Required permissions:**    - **nucleus.jail.create**   
     * @summary Create a jail
     * @param {NucleusNamedLocation} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public createJail(body?: NucleusNamedLocation, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).createJail(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new kit.     **Required permissions:**    - **nucleus.kit.create**   
     * @summary Create a kit
     * @param {NucleusKit} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public createKit(body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).createKit(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing jail.     **Required permissions:**    - **nucleus.jail.delete**   
     * @summary Delete a jail
     * @param {string} name 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public deleteJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).deleteJail(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing kit.     **Required permissions:**    - **nucleus.kit.delete**   
     * @summary Delete a kit
     * @param {string} name 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public deleteKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).deleteKit(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a jail.     **Required permissions:**    - **nucleus.jail.one**   
     * @summary Get a jail
     * @param {string} name 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public getJail(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).getJail(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a kit.     **Required permissions:**    - **nucleus.kit.one**   
     * @summary Get a kit
     * @param {string} name 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public getKit(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).getKit(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the homes of a player.     **Required permissions:**    - **nucleus.home.list**   
     * @summary List homes
     * @param {string} player The uuid of the player
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public listHomes(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).listHomes(player, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the jails on the server.     **Required permissions:**    - **nucleus.jail.list**   
     * @summary List jails
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public listJails(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).listJails(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the kits on the server.     **Required permissions:**    - **nucleus.kit.list**   
     * @summary List kits
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public listKits(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).listKits(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all mail messages of a player.     **Required permissions:**    - **nucleus.mail.list**   
     * @summary List mail
     * @param {string} player The uuid of the player
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public listMail(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).listMail(player, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of loaded Nucleus modules.     **Required permissions:**    - **nucleus.module.list**   
     * @summary List modules
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public listMail_1(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).listMail_1(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify an existing jail.     **Required permissions:**    - **nucleus.jail.modify**   
     * @summary Modify a jail
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public modifyJail(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).modifyJail(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify an existing kit.     **Required permissions:**    - **nucleus.kit.modify**   
     * @summary Modify a kit
     * @param {string} name 
     * @param {NucleusKit} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NucleusApi
     */
    public modifyKit(name: string, body?: NucleusKit, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return NucleusApiFp(this.configuration).modifyKit(name, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * PermissionApi - fetch parameter creator
 * @export
 */
export const PermissionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific subject collection     **Required permissions:**    - **permission.collection.one**   
         * @summary Get collection
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCollection.');
            }
            const localVarPath = `/permission/collection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets one specific subject belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.one**   
         * @summary Get subject
         * @param {string} id 
         * @param {string} subId 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject(id: string, subId: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSubject.');
            }
            // verify required parameter 'subId' is not null or undefined
            if (subId === null || subId === undefined) {
                throw new RequiredError('subId','Required parameter subId was null or undefined when calling getSubject.');
            }
            const localVarPath = `/permission/collection/{id}/subject/{subId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"subId"}}`, encodeURIComponent(String(subId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the subject collections, for example groups, users, etc.     **Required permissions:**    - **permission.collection.list**   
         * @summary List collections
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/permission/collection`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all subjects belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.list**   
         * @summary List subjects
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubjects(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubjects.');
            }
            const localVarPath = `/permission/collection/{id}/subject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a specific subject collection     **Required permissions:**    - **permission.collection.one**   
         * @summary Get collection
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubjectCollection> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).getCollection(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets one specific subject belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.one**   
         * @summary Get subject
         * @param {string} id 
         * @param {string} subId 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject(id: string, subId: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subject> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).getSubject(id, subId, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all the subject collections, for example groups, users, etc.     **Required permissions:**    - **permission.collection.list**   
         * @summary List collections
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SubjectCollection>> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).listCollections(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all subjects belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.list**   
         * @summary List subjects
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubjects(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subject>> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).listSubjects(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets a specific subject collection     **Required permissions:**    - **permission.collection.one**   
         * @summary Get collection
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PermissionApiFp(configuration).getCollection(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets one specific subject belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.one**   
         * @summary Get subject
         * @param {string} id 
         * @param {string} subId 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubject(id: string, subId: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PermissionApiFp(configuration).getSubject(id, subId, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a list of all the subject collections, for example groups, users, etc.     **Required permissions:**    - **permission.collection.list**   
         * @summary List collections
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PermissionApiFp(configuration).listCollections(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * List all subjects belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.list**   
         * @summary List subjects
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubjects(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PermissionApiFp(configuration).listSubjects(id, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * Gets a specific subject collection     **Required permissions:**    - **permission.collection.one**   
     * @summary Get collection
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public getCollection(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PermissionApiFp(this.configuration).getCollection(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets one specific subject belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.one**   
     * @summary Get subject
     * @param {string} id 
     * @param {string} subId 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public getSubject(id: string, subId: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PermissionApiFp(this.configuration).getSubject(id, subId, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all the subject collections, for example groups, users, etc.     **Required permissions:**    - **permission.collection.list**   
     * @summary List collections
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public listCollections(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PermissionApiFp(this.configuration).listCollections(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * List all subjects belonging to a certain collection     **Required permissions:**    - **permission.collection.subject.list**   
     * @summary List subjects
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public listSubjects(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PermissionApiFp(this.configuration).listSubjects(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * PlayerApi - fetch parameter creator
 * @export
 */
export const PlayerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides direct access to the underlying player object and can execute any method on it.     **Required permissions:**    - **player.method**   
         * @summary Execute a method
         * @param {string} player The uuid of the player
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(player: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling executeMethod.');
            }
            const localVarPath = `/player/{player}/method`
                .replace(`{${"player"}}`, encodeURIComponent(String(player)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteMethodRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a player.     **Required permissions:**    - **player.one**   
         * @summary Get a player
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling getPlayer.');
            }
            const localVarPath = `/player/{player}`
                .replace(`{${"player"}}`, encodeURIComponent(String(player)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the players on the server.     **Required permissions:**    - **player.list**   
         * @summary List players
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/player`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of an existing player.     **Required permissions:**    - **player.modify**   
         * @summary Modify a player
         * @param {string} player The uuid of the player
         * @param {UpdatePlayerRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPlayer(player: string, body?: UpdatePlayerRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling modifyPlayer.');
            }
            const localVarPath = `/player/{player}`
                .replace(`{${"player"}}`, encodeURIComponent(String(player)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePlayerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides direct access to the underlying player object and can execute any method on it.     **Required permissions:**    - **player.method**   
         * @summary Execute a method
         * @param {string} player The uuid of the player
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(player: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecuteMethodResponse> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).executeMethod(player, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a player.     **Required permissions:**    - **player.one**   
         * @summary Get a player
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).getPlayer(player, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the players on the server.     **Required permissions:**    - **player.list**   
         * @summary List players
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Player>> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).listPlayers(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify the properties of an existing player.     **Required permissions:**    - **player.modify**   
         * @summary Modify a player
         * @param {string} player The uuid of the player
         * @param {UpdatePlayerRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPlayer(player: string, body?: UpdatePlayerRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).modifyPlayer(player, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provides direct access to the underlying player object and can execute any method on it.     **Required permissions:**    - **player.method**   
         * @summary Execute a method
         * @param {string} player The uuid of the player
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(player: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PlayerApiFp(configuration).executeMethod(player, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a player.     **Required permissions:**    - **player.one**   
         * @summary Get a player
         * @param {string} player The uuid of the player
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PlayerApiFp(configuration).getPlayer(player, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the players on the server.     **Required permissions:**    - **player.list**   
         * @summary List players
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PlayerApiFp(configuration).listPlayers(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify the properties of an existing player.     **Required permissions:**    - **player.modify**   
         * @summary Modify a player
         * @param {string} player The uuid of the player
         * @param {UpdatePlayerRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPlayer(player: string, body?: UpdatePlayerRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PlayerApiFp(configuration).modifyPlayer(player, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
    /**
     * Provides direct access to the underlying player object and can execute any method on it.     **Required permissions:**    - **player.method**   
     * @summary Execute a method
     * @param {string} player The uuid of the player
     * @param {ExecuteMethodRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public executeMethod(player: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).executeMethod(player, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a player.     **Required permissions:**    - **player.one**   
     * @summary Get a player
     * @param {string} player The uuid of the player
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public getPlayer(player: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).getPlayer(player, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the players on the server.     **Required permissions:**    - **player.list**   
     * @summary List players
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public listPlayers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).listPlayers(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify the properties of an existing player.     **Required permissions:**    - **player.modify**   
     * @summary Modify a player
     * @param {string} player The uuid of the player
     * @param {UpdatePlayerRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public modifyPlayer(player: string, body?: UpdatePlayerRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).modifyPlayer(player, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * PluginApi - fetch parameter creator
 * @export
 */
export const PluginApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows changing the config files of plugin. Send a map from config filename to file contents. **This does not reload the plugin**, you can do that with `sponge plugins reload`, but not all plugins implement the reload event.     **Required permissions:**    - **plugin.config.modify**   - **plugin.config.modify.[plugin]**   
         * @summary Change plugin configs
         * @param {string} plugin The id of the plugin
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePluginConfig(plugin: string, body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'plugin' is not null or undefined
            if (plugin === null || plugin === undefined) {
                throw new RequiredError('plugin','Required parameter plugin was null or undefined when calling changePluginConfig.');
            }
            const localVarPath = `/plugin/{plugin}/config`
                .replace(`{${"plugin"}}`, encodeURIComponent(String(plugin)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information about a plugin.     **Required permissions:**    - **plugin.one**   
         * @summary Get a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'plugin' is not null or undefined
            if (plugin === null || plugin === undefined) {
                throw new RequiredError('plugin','Required parameter plugin was null or undefined when calling getPlugin.');
            }
            const localVarPath = `/plugin/{plugin}`
                .replace(`{${"plugin"}}`, encodeURIComponent(String(plugin)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a map containing the plugin config file names as keys, and their config file contents as their values.     **Required permissions:**    - **plugin.config.get**   
         * @summary Get plugin configs
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfig(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'plugin' is not null or undefined
            if (plugin === null || plugin === undefined) {
                throw new RequiredError('plugin','Required parameter plugin was null or undefined when calling getPluginConfig.');
            }
            const localVarPath = `/plugin/{plugin}/config`
                .replace(`{${"plugin"}}`, encodeURIComponent(String(plugin)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the plugins running on the server.     **Required permissions:**    - **plugin.list**   
         * @summary List plugins
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlugins(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/plugin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows enabling/disabling a plugin/mod. Requires a server restart.     **Required permissions:**    - **plugin.toggle**   
         * @summary Toggle a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        togglePlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'plugin' is not null or undefined
            if (plugin === null || plugin === undefined) {
                throw new RequiredError('plugin','Required parameter plugin was null or undefined when calling togglePlugin.');
            }
            const localVarPath = `/plugin/{plugin}`
                .replace(`{${"plugin"}}`, encodeURIComponent(String(plugin)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginApi - functional programming interface
 * @export
 */
export const PluginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Allows changing the config files of plugin. Send a map from config filename to file contents. **This does not reload the plugin**, you can do that with `sponge plugins reload`, but not all plugins implement the reload event.     **Required permissions:**    - **plugin.config.modify**   - **plugin.config.modify.[plugin]**   
         * @summary Change plugin configs
         * @param {string} plugin The id of the plugin
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePluginConfig(plugin: string, body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: any; }> {
            const localVarFetchArgs = PluginApiFetchParamCreator(configuration).changePluginConfig(plugin, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets detailed information about a plugin.     **Required permissions:**    - **plugin.one**   
         * @summary Get a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PluginContainer> {
            const localVarFetchArgs = PluginApiFetchParamCreator(configuration).getPlugin(plugin, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a map containing the plugin config file names as keys, and their config file contents as their values.     **Required permissions:**    - **plugin.config.get**   
         * @summary Get plugin configs
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfig(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: any; }> {
            const localVarFetchArgs = PluginApiFetchParamCreator(configuration).getPluginConfig(plugin, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the plugins running on the server.     **Required permissions:**    - **plugin.list**   
         * @summary List plugins
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlugins(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PluginContainer>> {
            const localVarFetchArgs = PluginApiFetchParamCreator(configuration).listPlugins(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allows enabling/disabling a plugin/mod. Requires a server restart.     **Required permissions:**    - **plugin.toggle**   
         * @summary Toggle a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        togglePlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PluginContainer> {
            const localVarFetchArgs = PluginApiFetchParamCreator(configuration).togglePlugin(plugin, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PluginApi - factory interface
 * @export
 */
export const PluginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Allows changing the config files of plugin. Send a map from config filename to file contents. **This does not reload the plugin**, you can do that with `sponge plugins reload`, but not all plugins implement the reload event.     **Required permissions:**    - **plugin.config.modify**   - **plugin.config.modify.[plugin]**   
         * @summary Change plugin configs
         * @param {string} plugin The id of the plugin
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePluginConfig(plugin: string, body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PluginApiFp(configuration).changePluginConfig(plugin, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets detailed information about a plugin.     **Required permissions:**    - **plugin.one**   
         * @summary Get a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PluginApiFp(configuration).getPlugin(plugin, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a map containing the plugin config file names as keys, and their config file contents as their values.     **Required permissions:**    - **plugin.config.get**   
         * @summary Get plugin configs
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfig(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PluginApiFp(configuration).getPluginConfig(plugin, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the plugins running on the server.     **Required permissions:**    - **plugin.list**   
         * @summary List plugins
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlugins(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PluginApiFp(configuration).listPlugins(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Allows enabling/disabling a plugin/mod. Requires a server restart.     **Required permissions:**    - **plugin.toggle**   
         * @summary Toggle a plugin
         * @param {string} plugin The id of the plugin
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        togglePlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return PluginApiFp(configuration).togglePlugin(plugin, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * PluginApi - object-oriented interface
 * @export
 * @class PluginApi
 * @extends {BaseAPI}
 */
export class PluginApi extends BaseAPI {
    /**
     * Allows changing the config files of plugin. Send a map from config filename to file contents. **This does not reload the plugin**, you can do that with `sponge plugins reload`, but not all plugins implement the reload event.     **Required permissions:**    - **plugin.config.modify**   - **plugin.config.modify.[plugin]**   
     * @summary Change plugin configs
     * @param {string} plugin The id of the plugin
     * @param {any} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public changePluginConfig(plugin: string, body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PluginApiFp(this.configuration).changePluginConfig(plugin, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets detailed information about a plugin.     **Required permissions:**    - **plugin.one**   
     * @summary Get a plugin
     * @param {string} plugin The id of the plugin
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public getPlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PluginApiFp(this.configuration).getPlugin(plugin, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a map containing the plugin config file names as keys, and their config file contents as their values.     **Required permissions:**    - **plugin.config.get**   
     * @summary Get plugin configs
     * @param {string} plugin The id of the plugin
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public getPluginConfig(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PluginApiFp(this.configuration).getPluginConfig(plugin, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the plugins running on the server.     **Required permissions:**    - **plugin.list**   
     * @summary List plugins
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public listPlugins(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PluginApiFp(this.configuration).listPlugins(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Allows enabling/disabling a plugin/mod. Requires a server restart.     **Required permissions:**    - **plugin.toggle**   
     * @summary Toggle a plugin
     * @param {string} plugin The id of the plugin
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public togglePlugin(plugin: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return PluginApiFp(this.configuration).togglePlugin(plugin, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * RecipeApi - fetch parameter creator
 * @export
 */
export const RecipeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      **Required permissions:**    - **recipe.list**   
         * @summary List recipes
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/recipe`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipeApi - functional programming interface
 * @export
 */
export const RecipeApiFp = function(configuration?: Configuration) {
    return {
        /**
         *      **Required permissions:**    - **recipe.list**   
         * @summary List recipes
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).listRecipes(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecipeApi - factory interface
 * @export
 */
export const RecipeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *      **Required permissions:**    - **recipe.list**   
         * @summary List recipes
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RecipeApiFp(configuration).listRecipes(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * RecipeApi - object-oriented interface
 * @export
 * @class RecipeApi
 * @extends {BaseAPI}
 */
export class RecipeApi extends BaseAPI {
    /**
     *      **Required permissions:**    - **recipe.list**   
     * @summary List recipes
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public listRecipes(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RecipeApiFp(this.configuration).listRecipes(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * RedProtectApi - fetch parameter creator
 * @export
 */
export const RedProtectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new region at a specified location     **Required permissions:**    - **red-protect.region.create**   
         * @summary Create a region
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegion(body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/red-protect/region`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RedProtectRegion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified protected region     **Required permissions:**    - **red-protect.region.delete**   
         * @summary Delete a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRegion.');
            }
            const localVarPath = `/red-protect/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details for a specific protected region     **Required permissions:**    - **red-protect.region.one**   
         * @summary Get a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRegion.');
            }
            const localVarPath = `/red-protect/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the regions being protected     **Required permissions:**    - **red-protect.region.list**   
         * @summary List regions
         * @param {string} [world] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(world?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/red-protect/region`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (world !== undefined) {
                localVarQueryParameter['world'] = world;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details for a specific protected region     **Required permissions:**    - **red-protect.region.modify**   
         * @summary Modify a region
         * @param {string} id 
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRegion(id: string, body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyRegion.');
            }
            const localVarPath = `/red-protect/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RedProtectRegion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedProtectApi - functional programming interface
 * @export
 */
export const RedProtectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new region at a specified location     **Required permissions:**    - **red-protect.region.create**   
         * @summary Create a region
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegion(body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedProtectRegion> {
            const localVarFetchArgs = RedProtectApiFetchParamCreator(configuration).createRegion(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove the specified protected region     **Required permissions:**    - **red-protect.region.delete**   
         * @summary Delete a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedProtectRegion> {
            const localVarFetchArgs = RedProtectApiFetchParamCreator(configuration).deleteRegion(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details for a specific protected region     **Required permissions:**    - **red-protect.region.one**   
         * @summary Get a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedProtectRegion> {
            const localVarFetchArgs = RedProtectApiFetchParamCreator(configuration).getRegion(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all the regions being protected     **Required permissions:**    - **red-protect.region.list**   
         * @summary List regions
         * @param {string} [world] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(world?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RedProtectRegion>> {
            const localVarFetchArgs = RedProtectApiFetchParamCreator(configuration).listRegions(world, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the details for a specific protected region     **Required permissions:**    - **red-protect.region.modify**   
         * @summary Modify a region
         * @param {string} id 
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRegion(id: string, body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RedProtectRegion> {
            const localVarFetchArgs = RedProtectApiFetchParamCreator(configuration).modifyRegion(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RedProtectApi - factory interface
 * @export
 */
export const RedProtectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new region at a specified location     **Required permissions:**    - **red-protect.region.create**   
         * @summary Create a region
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegion(body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RedProtectApiFp(configuration).createRegion(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Remove the specified protected region     **Required permissions:**    - **red-protect.region.delete**   
         * @summary Delete a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RedProtectApiFp(configuration).deleteRegion(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get details for a specific protected region     **Required permissions:**    - **red-protect.region.one**   
         * @summary Get a region
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RedProtectApiFp(configuration).getRegion(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Lists all the regions being protected     **Required permissions:**    - **red-protect.region.list**   
         * @summary List regions
         * @param {string} [world] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(world?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RedProtectApiFp(configuration).listRegions(world, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Update the details for a specific protected region     **Required permissions:**    - **red-protect.region.modify**   
         * @summary Modify a region
         * @param {string} id 
         * @param {RedProtectRegion} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRegion(id: string, body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RedProtectApiFp(configuration).modifyRegion(id, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * RedProtectApi - object-oriented interface
 * @export
 * @class RedProtectApi
 * @extends {BaseAPI}
 */
export class RedProtectApi extends BaseAPI {
    /**
     * Create a new region at a specified location     **Required permissions:**    - **red-protect.region.create**   
     * @summary Create a region
     * @param {RedProtectRegion} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedProtectApi
     */
    public createRegion(body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RedProtectApiFp(this.configuration).createRegion(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Remove the specified protected region     **Required permissions:**    - **red-protect.region.delete**   
     * @summary Delete a region
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedProtectApi
     */
    public deleteRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RedProtectApiFp(this.configuration).deleteRegion(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get details for a specific protected region     **Required permissions:**    - **red-protect.region.one**   
     * @summary Get a region
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedProtectApi
     */
    public getRegion(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RedProtectApiFp(this.configuration).getRegion(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all the regions being protected     **Required permissions:**    - **red-protect.region.list**   
     * @summary List regions
     * @param {string} [world] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedProtectApi
     */
    public listRegions(world?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RedProtectApiFp(this.configuration).listRegions(world, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Update the details for a specific protected region     **Required permissions:**    - **red-protect.region.modify**   
     * @summary Modify a region
     * @param {string} id 
     * @param {RedProtectRegion} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedProtectApi
     */
    public modifyRegion(id: string, body?: RedProtectRegion, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RedProtectApiFp(this.configuration).modifyRegion(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * RegistryApi - fetch parameter creator
 * @export
 */
export const RegistryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all the catalog values of a specified CatalogType.     **Required permissions:**    - **registry.one**   
         * @summary Get a catalog type
         * @param {string} _class The fully qualified classname of the catalog type
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistry(_class: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter '_class' is not null or undefined
            if (_class === null || _class === undefined) {
                throw new RequiredError('_class','Required parameter _class was null or undefined when calling getRegistry.');
            }
            const localVarPath = `/registry/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists all the catalog values of a specified CatalogType.     **Required permissions:**    - **registry.one**   
         * @summary Get a catalog type
         * @param {string} _class The fully qualified classname of the catalog type
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistry(_class: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogType>> {
            const localVarFetchArgs = RegistryApiFetchParamCreator(configuration).getRegistry(_class, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists all the catalog values of a specified CatalogType.     **Required permissions:**    - **registry.one**   
         * @summary Get a catalog type
         * @param {string} _class The fully qualified classname of the catalog type
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistry(_class: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return RegistryApiFp(configuration).getRegistry(_class, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * Lists all the catalog values of a specified CatalogType.     **Required permissions:**    - **registry.one**   
     * @summary Get a catalog type
     * @param {string} _class The fully qualified classname of the catalog type
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public getRegistry(_class: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return RegistryApiFp(this.configuration).getRegistry(_class, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * ServerApi - fetch parameter creator
 * @export
 */
export const ServerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the main server properties (server.properties file).     **Required permissions:**    - **server.properties.list**   
         * @summary List server properties
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProperties(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/server/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify settings in the server.properties file. **Note that these settings don't take effect until you restart the server.     **Required permissions:**    - **server.properties.modify**   - **server.properties.modify.[property]**   
         * @summary Modify server properties
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProperties(body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/server/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the main server properties (server.properties file).     **Required permissions:**    - **server.properties.list**   
         * @summary List server properties
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProperties(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ServerProperty>> {
            const localVarFetchArgs = ServerApiFetchParamCreator(configuration).listProperties(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify settings in the server.properties file. **Note that these settings don't take effect until you restart the server.     **Required permissions:**    - **server.properties.modify**   - **server.properties.modify.[property]**   
         * @summary Modify server properties
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProperties(body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ServerProperty>> {
            const localVarFetchArgs = ServerApiFetchParamCreator(configuration).modifyProperties(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the main server properties (server.properties file).     **Required permissions:**    - **server.properties.list**   
         * @summary List server properties
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProperties(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ServerApiFp(configuration).listProperties(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify settings in the server.properties file. **Note that these settings don't take effect until you restart the server.     **Required permissions:**    - **server.properties.modify**   - **server.properties.modify.[property]**   
         * @summary Modify server properties
         * @param {any} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProperties(body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return ServerApiFp(configuration).modifyProperties(body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Get the main server properties (server.properties file).     **Required permissions:**    - **server.properties.list**   
     * @summary List server properties
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public listProperties(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ServerApiFp(this.configuration).listProperties(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify settings in the server.properties file. **Note that these settings don't take effect until you restart the server.     **Required permissions:**    - **server.properties.modify**   - **server.properties.modify.[property]**   
     * @summary Modify server properties
     * @param {any} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public modifyProperties(body?: any, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return ServerApiFp(this.configuration).modifyProperties(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * TileEntityApi - fetch parameter creator
 * @export
 */
export const TileEntityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides direct access to the underlaying tile entity object and can execute any method on it.     **Required permissions:**    - **tile-entity.method**   
         * @summary Execute a method
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The x-coordinate of the tile-entity
         * @param {number} z The x-coordinate of the tile-entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, x: number, y: number, z: number, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling executeMethod.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling executeMethod.');
            }
            // verify required parameter 'y' is not null or undefined
            if (y === null || y === undefined) {
                throw new RequiredError('y','Required parameter y was null or undefined when calling executeMethod.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling executeMethod.');
            }
            const localVarPath = `/tile-entity/{world}/{x}/{y}/{z}/method`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteMethodRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a tile entity.     **Required permissions:**    - **tile-entity.one**   
         * @summary Get tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTileEntity(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling getTileEntity.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling getTileEntity.');
            }
            // verify required parameter 'y' is not null or undefined
            if (y === null || y === undefined) {
                throw new RequiredError('y','Required parameter y was null or undefined when calling getTileEntity.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling getTileEntity.');
            }
            const localVarPath = `/tile-entity/{world}/{x}/{y}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all tile entities on the server (in all worlds, unless specified).     **Required permissions:**    - **tile-entity.list**   
         * @summary List tile entities
         * @param {string} [world] The world to filter tile entities by
         * @param {string} [type] The type if of tile entities to filter by
         * @param {string} [min] The minimum coordinates at which the tile entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the tile entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of tile entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTileEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/tile-entity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (world !== undefined) {
                localVarQueryParameter['world'] = world;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of an existing tile entity.     **Required permissions:**    - **tile-entity.modify**   
         * @summary Modify tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {UpdateTileEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTileEntity(world: string, x: number, y: number, z: number, body?: UpdateTileEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling modifyTileEntity.');
            }
            // verify required parameter 'x' is not null or undefined
            if (x === null || x === undefined) {
                throw new RequiredError('x','Required parameter x was null or undefined when calling modifyTileEntity.');
            }
            // verify required parameter 'y' is not null or undefined
            if (y === null || y === undefined) {
                throw new RequiredError('y','Required parameter y was null or undefined when calling modifyTileEntity.');
            }
            // verify required parameter 'z' is not null or undefined
            if (z === null || z === undefined) {
                throw new RequiredError('z','Required parameter z was null or undefined when calling modifyTileEntity.');
            }
            const localVarPath = `/tile-entity/{world}/{x}/{y}/{z}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateTileEntityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TileEntityApi - functional programming interface
 * @export
 */
export const TileEntityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides direct access to the underlaying tile entity object and can execute any method on it.     **Required permissions:**    - **tile-entity.method**   
         * @summary Execute a method
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The x-coordinate of the tile-entity
         * @param {number} z The x-coordinate of the tile-entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, x: number, y: number, z: number, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecuteMethodResponse> {
            const localVarFetchArgs = TileEntityApiFetchParamCreator(configuration).executeMethod(world, x, y, z, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a tile entity.     **Required permissions:**    - **tile-entity.one**   
         * @summary Get tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTileEntity(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TileEntity> {
            const localVarFetchArgs = TileEntityApiFetchParamCreator(configuration).getTileEntity(world, x, y, z, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all tile entities on the server (in all worlds, unless specified).     **Required permissions:**    - **tile-entity.list**   
         * @summary List tile entities
         * @param {string} [world] The world to filter tile entities by
         * @param {string} [type] The type if of tile entities to filter by
         * @param {string} [min] The minimum coordinates at which the tile entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the tile entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of tile entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTileEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TileEntity>> {
            const localVarFetchArgs = TileEntityApiFetchParamCreator(configuration).listTileEntities(world, type, min, max, limit, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify the properties of an existing tile entity.     **Required permissions:**    - **tile-entity.modify**   
         * @summary Modify tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {UpdateTileEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTileEntity(world: string, x: number, y: number, z: number, body?: UpdateTileEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TileEntity> {
            const localVarFetchArgs = TileEntityApiFetchParamCreator(configuration).modifyTileEntity(world, x, y, z, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TileEntityApi - factory interface
 * @export
 */
export const TileEntityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provides direct access to the underlaying tile entity object and can execute any method on it.     **Required permissions:**    - **tile-entity.method**   
         * @summary Execute a method
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The x-coordinate of the tile-entity
         * @param {number} z The x-coordinate of the tile-entity
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, x: number, y: number, z: number, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return TileEntityApiFp(configuration).executeMethod(world, x, y, z, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a tile entity.     **Required permissions:**    - **tile-entity.one**   
         * @summary Get tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTileEntity(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return TileEntityApiFp(configuration).getTileEntity(world, x, y, z, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all tile entities on the server (in all worlds, unless specified).     **Required permissions:**    - **tile-entity.list**   
         * @summary List tile entities
         * @param {string} [world] The world to filter tile entities by
         * @param {string} [type] The type if of tile entities to filter by
         * @param {string} [min] The minimum coordinates at which the tile entity must be, min&#x3D;x|y|z
         * @param {string} [max] The maximum coordinates at which the tile entity must be, max&#x3D;x|y|z
         * @param {number} [limit] The maximum amount of tile entities returned
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTileEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return TileEntityApiFp(configuration).listTileEntities(world, type, min, max, limit, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify the properties of an existing tile entity.     **Required permissions:**    - **tile-entity.modify**   
         * @summary Modify tile entity
         * @param {string} world The world the tile entity is in
         * @param {number} x The x-coordinate of the tile-entity
         * @param {number} y The y-coordinate of the tile-entity
         * @param {number} z The z-coordinate of the tile-entity
         * @param {UpdateTileEntityRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTileEntity(world: string, x: number, y: number, z: number, body?: UpdateTileEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return TileEntityApiFp(configuration).modifyTileEntity(world, x, y, z, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * TileEntityApi - object-oriented interface
 * @export
 * @class TileEntityApi
 * @extends {BaseAPI}
 */
export class TileEntityApi extends BaseAPI {
    /**
     * Provides direct access to the underlaying tile entity object and can execute any method on it.     **Required permissions:**    - **tile-entity.method**   
     * @summary Execute a method
     * @param {string} world The world the tile entity is in
     * @param {number} x The x-coordinate of the tile-entity
     * @param {number} y The x-coordinate of the tile-entity
     * @param {number} z The x-coordinate of the tile-entity
     * @param {ExecuteMethodRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TileEntityApi
     */
    public executeMethod(world: string, x: number, y: number, z: number, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return TileEntityApiFp(this.configuration).executeMethod(world, x, y, z, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a tile entity.     **Required permissions:**    - **tile-entity.one**   
     * @summary Get tile entity
     * @param {string} world The world the tile entity is in
     * @param {number} x The x-coordinate of the tile-entity
     * @param {number} y The y-coordinate of the tile-entity
     * @param {number} z The z-coordinate of the tile-entity
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TileEntityApi
     */
    public getTileEntity(world: string, x: number, y: number, z: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return TileEntityApiFp(this.configuration).getTileEntity(world, x, y, z, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all tile entities on the server (in all worlds, unless specified).     **Required permissions:**    - **tile-entity.list**   
     * @summary List tile entities
     * @param {string} [world] The world to filter tile entities by
     * @param {string} [type] The type if of tile entities to filter by
     * @param {string} [min] The minimum coordinates at which the tile entity must be, min&#x3D;x|y|z
     * @param {string} [max] The maximum coordinates at which the tile entity must be, max&#x3D;x|y|z
     * @param {number} [limit] The maximum amount of tile entities returned
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TileEntityApi
     */
    public listTileEntities(world?: string, type?: string, min?: string, max?: string, limit?: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return TileEntityApiFp(this.configuration).listTileEntities(world, type, min, max, limit, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify the properties of an existing tile entity.     **Required permissions:**    - **tile-entity.modify**   
     * @summary Modify tile entity
     * @param {string} world The world the tile entity is in
     * @param {number} x The x-coordinate of the tile-entity
     * @param {number} y The y-coordinate of the tile-entity
     * @param {number} z The z-coordinate of the tile-entity
     * @param {UpdateTileEntityRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TileEntityApi
     */
    public modifyTileEntity(world: string, x: number, y: number, z: number, body?: UpdateTileEntityRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return TileEntityApiFp(this.configuration).modifyTileEntity(world, x, y, z, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * UniversalMarketApi - fetch parameter creator
 * @export
 */
export const UniversalMarketApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all the items in the market currently available for sale     **Required permissions:**    - **universal-market.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/universal-market/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniversalMarketApi - functional programming interface
 * @export
 */
export const UniversalMarketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists all the items in the market currently available for sale     **Required permissions:**    - **universal-market.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UniversalMarketItem>> {
            const localVarFetchArgs = UniversalMarketApiFetchParamCreator(configuration).listMarketItems(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UniversalMarketApi - factory interface
 * @export
 */
export const UniversalMarketApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists all the items in the market currently available for sale     **Required permissions:**    - **universal-market.item.list**   
         * @summary List items
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UniversalMarketApiFp(configuration).listMarketItems(details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * UniversalMarketApi - object-oriented interface
 * @export
 * @class UniversalMarketApi
 * @extends {BaseAPI}
 */
export class UniversalMarketApi extends BaseAPI {
    /**
     * Lists all the items in the market currently available for sale     **Required permissions:**    - **universal-market.item.list**   
     * @summary List items
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalMarketApi
     */
    public listMarketItems(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UniversalMarketApiFp(this.configuration).listMarketItems(details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Web-API user with the specified username and password.     **Required permissions:**    - **user.create**   
         * @summary Create a user
         * @param {CreateUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body?: CreateUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Web-API user.     **Required permissions:**    - **user.delete**   
         * @summary Delete a user
         * @param {string} name The username of the user to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks to see if the passed api key is still valid and retrieves the user info and permissions associated with this key     **Required permissions:**    - **user.**   
         * @summary Check info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the Web-API users.     **Required permissions:**    - **user.list**   
         * @summary List users
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to acquire an api key with the passed credentials.
         * @summary Login
         * @param {AuthenticationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: AuthenticationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthenticationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate the current API key, logging out the active user.     **Required permissions:**    - **user.**   
         * @summary Logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * null     **Required permissions:**    - **user.**   
         * @param {string} [redirect] The URL the client should be redirect to after logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutRedirect(redirect?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the properties of a Web-API user     **Required permissions:**    - **user.modify**   
         * @summary Update a user
         * @param {string} name The username of the user to delete
         * @param {ModifyUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(name: string, body?: ModifyUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling modifyUser.');
            }
            const localVarPath = `/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ModifyUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new Web-API user with the specified username and password.     **Required permissions:**    - **user.create**   
         * @summary Create a user
         * @param {CreateUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body?: CreateUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes a Web-API user.     **Required permissions:**    - **user.delete**   
         * @summary Delete a user
         * @param {string} name The username of the user to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(name, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Checks to see if the passed api key is still valid and retrieves the user info and permissions associated with this key     **Required permissions:**    - **user.**   
         * @summary Check info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getMe(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all the Web-API users.     **Required permissions:**    - **user.list**   
         * @summary List users
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserPermissionStruct>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsers(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to acquire an api key with the passed credentials.
         * @summary Login
         * @param {AuthenticationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: AuthenticationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).login(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invalidate the current API key, logging out the active user.     **Required permissions:**    - **user.**   
         * @summary Logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).logout(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * null     **Required permissions:**    - **user.**   
         * @param {string} [redirect] The URL the client should be redirect to after logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutRedirect(redirect?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).logoutRedirect(redirect, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes the properties of a Web-API user     **Required permissions:**    - **user.modify**   
         * @summary Update a user
         * @param {string} name The username of the user to delete
         * @param {ModifyUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(name: string, body?: ModifyUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPermissionStruct> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).modifyUser(name, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new Web-API user with the specified username and password.     **Required permissions:**    - **user.create**   
         * @summary Create a user
         * @param {CreateUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body?: CreateUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).createUser(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Removes a Web-API user.     **Required permissions:**    - **user.delete**   
         * @summary Delete a user
         * @param {string} name The username of the user to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).deleteUser(name, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Checks to see if the passed api key is still valid and retrieves the user info and permissions associated with this key     **Required permissions:**    - **user.**   
         * @summary Check info
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).getMe(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Gets a list of all the Web-API users.     **Required permissions:**    - **user.list**   
         * @summary List users
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).getUsers(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Tries to acquire an api key with the passed credentials.
         * @summary Login
         * @param {AuthenticationRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: AuthenticationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).login(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Invalidate the current API key, logging out the active user.     **Required permissions:**    - **user.**   
         * @summary Logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).logout(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * null     **Required permissions:**    - **user.**   
         * @param {string} [redirect] The URL the client should be redirect to after logout
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutRedirect(redirect?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).logoutRedirect(redirect, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Changes the properties of a Web-API user     **Required permissions:**    - **user.modify**   
         * @summary Update a user
         * @param {string} name The username of the user to delete
         * @param {ModifyUserRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(name: string, body?: ModifyUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return UserApiFp(configuration).modifyUser(name, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Creates a new Web-API user with the specified username and password.     **Required permissions:**    - **user.create**   
     * @summary Create a user
     * @param {CreateUserRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(body?: CreateUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).createUser(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Removes a Web-API user.     **Required permissions:**    - **user.delete**   
     * @summary Delete a user
     * @param {string} name The username of the user to delete
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(name: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).deleteUser(name, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Checks to see if the passed api key is still valid and retrieves the user info and permissions associated with this key     **Required permissions:**    - **user.**   
     * @summary Check info
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).getMe(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all the Web-API users.     **Required permissions:**    - **user.list**   
     * @summary List users
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).getUsers(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Tries to acquire an api key with the passed credentials.
     * @summary Login
     * @param {AuthenticationRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(body?: AuthenticationRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).login(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Invalidate the current API key, logging out the active user.     **Required permissions:**    - **user.**   
     * @summary Logout
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logout(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).logout(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * null     **Required permissions:**    - **user.**   
     * @param {string} [redirect] The URL the client should be redirect to after logout
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logoutRedirect(redirect?: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).logoutRedirect(redirect, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Changes the properties of a Web-API user     **Required permissions:**    - **user.modify**   
     * @summary Update a user
     * @param {string} name The username of the user to delete
     * @param {ModifyUserRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUser(name: string, body?: ModifyUserRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return UserApiFp(this.configuration).modifyUser(name, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * VShopsApi - fetch parameter creator
 * @export
 */
export const VShopsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling deleteShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling getShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listShopItems.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VShopsApi - functional programming interface
 * @export
 */
export const VShopsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).addShopItem(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).createShop(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).deleteShop(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).deleteShopItem(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).getShop(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).getShopItem(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsStockItem>> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).listShopItems(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsShop>> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).listShops(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).updateShop(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VShopsApiFetchParamCreator(configuration).updateShopItem(id, item, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VShopsApi - factory interface
 * @export
 */
export const VShopsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).addShopItem(id, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).createShop(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).deleteShop(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).deleteShopItem(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).getShop(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).getShopItem(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).listShopItems(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).listShops(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).updateShop(id, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VShopsApiFp(configuration).updateShopItem(id, item, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * VShopsApi - object-oriented interface
 * @export
 * @class VShopsApi
 * @extends {BaseAPI}
 */
export class VShopsApi extends BaseAPI {
    /**
     * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
     * @summary Add Shop Item
     * @param {string} id 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).addShopItem(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
     * @summary Create Shops
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).createShop(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
     * @summary Delete a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).deleteShop(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
     * @summary Removes a Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).deleteShopItem(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).getShop(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).getShopItem(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
     * @summary List Shop Items
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).listShopItems(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
     * @summary List Shops
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).listShops(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
     * @summary Change Shop
     * @param {string} id 
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).updateShop(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
     * @summary Change Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VShopsApi
     */
    public updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VShopsApiFp(this.configuration).updateShopItem(id, item, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * VillagerShopsApi - fetch parameter creator
 * @export
 */
export const VillagerShopsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem_1(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addShopItem_1.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop_2(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling deleteShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem_3(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShopItem_3.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling deleteShopItem_3.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop_4(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteShop_4.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling getShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem_5(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShopItem_5.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling getShopItem_5.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop_6(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShop_6.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listShopItems.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems_7(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listShopItems_7.');
            }
            const localVarPath = `/vshop/shop/{id}/item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops_8(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/vshop/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShop.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShopItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateShopItem.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem_9(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShopItem_9.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateShopItem_9.');
            }
            const localVarPath = `/vshop/shop/{id}/item/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsStockItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop_10(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateShop_10.');
            }
            const localVarPath = `/vshop/shop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VillagerShopsShop" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VillagerShopsApi - functional programming interface
 * @export
 */
export const VillagerShopsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).addShopItem(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem_1(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).addShopItem_1(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).createShop(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop_2(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).createShop_2(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).deleteShop(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).deleteShopItem(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem_3(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).deleteShopItem_3(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop_4(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).deleteShop_4(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).getShop(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).getShopItem(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem_5(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).getShopItem_5(id, item, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop_6(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).getShop_6(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsStockItem>> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).listShopItems(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems_7(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsStockItem>> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).listShopItems_7(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsShop>> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).listShops(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops_8(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VillagerShopsShop>> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).listShops_8(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).updateShop(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).updateShopItem(id, item, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem_9(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsStockItem> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).updateShopItem_9(id, item, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop_10(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VillagerShopsShop> {
            const localVarFetchArgs = VillagerShopsApiFetchParamCreator(configuration).updateShop_10(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VillagerShopsApi - factory interface
 * @export
 */
export const VillagerShopsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).addShopItem(id, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
         * @summary Add Shop Item
         * @param {string} id 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopItem_1(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).addShopItem_1(id, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).createShop(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
         * @summary Create Shops
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop_2(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).createShop_2(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).deleteShop(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).deleteShopItem(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
         * @summary Removes a Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopItem_3(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).deleteShopItem_3(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
         * @summary Delete a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShop_4(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).deleteShop_4(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).getShop(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).getShopItem(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {number} item 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopItem_5(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).getShopItem_5(id, item, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
         * @summary Get a Shop
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop_6(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).getShop_6(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).listShopItems(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
         * @summary List Shop Items
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShopItems_7(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).listShopItems_7(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).listShops(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
         * @summary List Shops
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShops_8(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).listShops_8(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).updateShop(id, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).updateShopItem(id, item, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
         * @summary Change Shop Item
         * @param {string} id 
         * @param {number} item 
         * @param {VillagerShopsStockItem} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopItem_9(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).updateShopItem_9(id, item, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
         * @summary Change Shop
         * @param {string} id 
         * @param {VillagerShopsShop} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop_10(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return VillagerShopsApiFp(configuration).updateShop_10(id, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * VillagerShopsApi - object-oriented interface
 * @export
 * @class VillagerShopsApi
 * @extends {BaseAPI}
 */
export class VillagerShopsApi extends BaseAPI {
    /**
     * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
     * @summary Add Shop Item
     * @param {string} id 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public addShopItem(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).addShopItem(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Add a item to the shops listing     **Required permissions:**    - **vshop.vshop.item.create**   
     * @summary Add Shop Item
     * @param {string} id 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public addShopItem_1(id: string, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).addShopItem_1(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
     * @summary Create Shops
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public createShop(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).createShop(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Spawn a new shop with base values; Some values are only set by update     **Required permissions:**    - **vshop.vshop.create**   
     * @summary Create Shops
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public createShop_2(body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).createShop_2(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
     * @summary Delete a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public deleteShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).deleteShop(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
     * @summary Removes a Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public deleteShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).deleteShopItem(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an item from this shop     **Required permissions:**    - **vshop.vshop.item.delete**   
     * @summary Removes a Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public deleteShopItem_3(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).deleteShopItem_3(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete a shop from the server     **Required permissions:**    - **vshop.vshop.delete**   
     * @summary Delete a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public deleteShop_4(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).deleteShop_4(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public getShop(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).getShop(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public getShopItem(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).getShopItem(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop item     **Required permissions:**    - **vshop.vshop.item.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {number} item 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public getShopItem_5(id: string, item: number, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).getShopItem_5(id, item, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a shop     **Required permissions:**    - **vshop.vshop.one**   
     * @summary Get a Shop
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public getShop_6(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).getShop_6(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
     * @summary List Shop Items
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public listShopItems(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).listShopItems(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops items     **Required permissions:**    - **vshop.vshop.item.list**   
     * @summary List Shop Items
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public listShopItems_7(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).listShopItems_7(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
     * @summary List Shops
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public listShops(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).listShops(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of all shops     **Required permissions:**    - **vshop.vshop.list**   
     * @summary List Shops
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public listShops_8(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).listShops_8(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
     * @summary Change Shop
     * @param {string} id 
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public updateShop(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).updateShop(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
     * @summary Change Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public updateShopItem(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).updateShopItem(id, item, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop item     **Required permissions:**    - **vshop.vshop.item.edit**   
     * @summary Change Shop Item
     * @param {string} id 
     * @param {number} item 
     * @param {VillagerShopsStockItem} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public updateShopItem_9(id: string, item: number, body?: VillagerShopsStockItem, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).updateShopItem_9(id, item, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modifies values for this shop, but items     **Required permissions:**    - **vshop.vshop.edit**   
     * @summary Change Shop
     * @param {string} id 
     * @param {VillagerShopsShop} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VillagerShopsApi
     */
    public updateShop_10(id: string, body?: VillagerShopsShop, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return VillagerShopsApiFp(this.configuration).updateShop_10(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * WebBooksApi - fetch parameter creator
 * @export
 */
export const WebBooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new web book from the specified data.     **Required permissions:**    - **web-books.book.create**   
         * @summary Create a book
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebBook(body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/web-books/book`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebBooksBook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a web book.     **Required permissions:**    - **web-books.book.delete**   
         * @summary Delete a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteWebBook.');
            }
            const localVarPath = `/web-books/book/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a web book.     **Required permissions:**    - **web-books.book.one**   
         * @summary Get a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getWebBook.');
            }
            const localVarPath = `/web-books/book/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContent(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getWebBookContent.');
            }
            const localVarPath = `/web-books/book/{id}/html`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContentPost(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getWebBookContentPost.');
            }
            const localVarPath = `/web-books/book/{id}/html`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the web books on the server.     **Required permissions:**    - **web-books.book.list**   
         * @summary List books
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebBooks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/web-books/book`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing book.     **Required permissions:**    - **web-books.book.modify**   
         * @summary Modify a book
         * @param {string} id 
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebBook(id: string, body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyWebBook.');
            }
            const localVarPath = `/web-books/book/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebBooksBook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebBooksApi - functional programming interface
 * @export
 */
export const WebBooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new web book from the specified data.     **Required permissions:**    - **web-books.book.create**   
         * @summary Create a book
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebBook(body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebBooksBook> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).createWebBook(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a web book.     **Required permissions:**    - **web-books.book.delete**   
         * @summary Delete a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebBooksBook> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).deleteWebBook(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a web book.     **Required permissions:**    - **web-books.book.one**   
         * @summary Get a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebBooksBook> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).getWebBook(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContent(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).getWebBookContent(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContentPost(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).getWebBookContentPost(id, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the web books on the server.     **Required permissions:**    - **web-books.book.list**   
         * @summary List books
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebBooks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebBooksBook>> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).listWebBooks(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify an existing book.     **Required permissions:**    - **web-books.book.modify**   
         * @summary Modify a book
         * @param {string} id 
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebBook(id: string, body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebBooksBook> {
            const localVarFetchArgs = WebBooksApiFetchParamCreator(configuration).modifyWebBook(id, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebBooksApi - factory interface
 * @export
 */
export const WebBooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new web book from the specified data.     **Required permissions:**    - **web-books.book.create**   
         * @summary Create a book
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebBook(body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).createWebBook(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Delete a web book.     **Required permissions:**    - **web-books.book.delete**   
         * @summary Delete a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).deleteWebBook(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a web book.     **Required permissions:**    - **web-books.book.one**   
         * @summary Get a book
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).getWebBook(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContent(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).getWebBookContent(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get the web book content as HTML.
         * @summary Book HTML
         * @param {string} id 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebBookContentPost(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).getWebBookContentPost(id, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the web books on the server.     **Required permissions:**    - **web-books.book.list**   
         * @summary List books
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebBooks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).listWebBooks(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify an existing book.     **Required permissions:**    - **web-books.book.modify**   
         * @summary Modify a book
         * @param {string} id 
         * @param {WebBooksBook} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebBook(id: string, body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WebBooksApiFp(configuration).modifyWebBook(id, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * WebBooksApi - object-oriented interface
 * @export
 * @class WebBooksApi
 * @extends {BaseAPI}
 */
export class WebBooksApi extends BaseAPI {
    /**
     * Create a new web book from the specified data.     **Required permissions:**    - **web-books.book.create**   
     * @summary Create a book
     * @param {WebBooksBook} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public createWebBook(body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).createWebBook(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a web book.     **Required permissions:**    - **web-books.book.delete**   
     * @summary Delete a book
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public deleteWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).deleteWebBook(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a web book.     **Required permissions:**    - **web-books.book.one**   
     * @summary Get a book
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public getWebBook(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).getWebBook(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get the web book content as HTML.
     * @summary Book HTML
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public getWebBookContent(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).getWebBookContent(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get the web book content as HTML.
     * @summary Book HTML
     * @param {string} id 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public getWebBookContentPost(id: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).getWebBookContentPost(id, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the web books on the server.     **Required permissions:**    - **web-books.book.list**   
     * @summary List books
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public listWebBooks(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).listWebBooks(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify an existing book.     **Required permissions:**    - **web-books.book.modify**   
     * @summary Modify a book
     * @param {string} id 
     * @param {WebBooksBook} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBooksApi
     */
    public modifyWebBook(id: string, body?: WebBooksBook, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WebBooksApiFp(this.configuration).modifyWebBook(id, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

/**
 * WorldApi - fetch parameter creator
 * @export
 */
export const WorldApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new world with the specified settings. This does not yet load the world.     **Required permissions:**    - **world.create**   
         * @summary Create a world
         * @param {CreateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld(body?: CreateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/world`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWorldRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing world. **The world must be unloaded before deleting it**     **Required permissions:**    - **world.delete**   
         * @summary Delete a world
         * @param {string} world The uuid of the world to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling deleteWorld.');
            }
            const localVarPath = `/world/{world}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides direct access to the underlaying world object and can execute any method on it.     **Required permissions:**    - **world.method**   
         * @summary Execute a method
         * @param {string} world The uuid of the world on which to execute the method
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling executeMethod.');
            }
            const localVarPath = `/world/{world}/method`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteMethodRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a world.     **Required permissions:**    - **world.one**   
         * @summary Get a world
         * @param {string} world The uuid of the world for which to get details
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling getWorld.');
            }
            const localVarPath = `/world/{world}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the worlds on the server.     **Required permissions:**    - **world.list**   
         * @summary List worlds
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorlds(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/world`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of an existing world.     **Required permissions:**    - **world.modify**   
         * @summary Modify a world
         * @param {string} world The uuid of the world which to update
         * @param {UpdateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWorld(world: string, body?: UpdateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'world' is not null or undefined
            if (world === null || world === undefined) {
                throw new RequiredError('world','Required parameter world was null or undefined when calling modifyWorld.');
            }
            const localVarPath = `/world/{world}`
                .replace(`{${"world"}}`, encodeURIComponent(String(world)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-WebAPI-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-WebAPI-Key"] = localVarApiKeyValue;
            }

            // authentication ApiKeyQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("key")
					: configuration.apiKey;
                localVarQueryParameter["key"] = localVarApiKeyValue;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateWorldRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldApi - functional programming interface
 * @export
 */
export const WorldApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new world with the specified settings. This does not yet load the world.     **Required permissions:**    - **world.create**   
         * @summary Create a world
         * @param {CreateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld(body?: CreateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<World> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).createWorld(body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an existing world. **The world must be unloaded before deleting it**     **Required permissions:**    - **world.delete**   
         * @summary Delete a world
         * @param {string} world The uuid of the world to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<World> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).deleteWorld(world, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Provides direct access to the underlaying world object and can execute any method on it.     **Required permissions:**    - **world.method**   
         * @summary Execute a method
         * @param {string} world The uuid of the world on which to execute the method
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExecuteMethodResponse> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).executeMethod(world, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get detailed information about a world.     **Required permissions:**    - **world.one**   
         * @summary Get a world
         * @param {string} world The uuid of the world for which to get details
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<World> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).getWorld(world, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the worlds on the server.     **Required permissions:**    - **world.list**   
         * @summary List worlds
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorlds(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<World>> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).listWorlds(details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify the properties of an existing world.     **Required permissions:**    - **world.modify**   
         * @summary Modify a world
         * @param {string} world The uuid of the world which to update
         * @param {UpdateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWorld(world: string, body?: UpdateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<World> {
            const localVarFetchArgs = WorldApiFetchParamCreator(configuration).modifyWorld(world, body, details, accept, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorldApi - factory interface
 * @export
 */
export const WorldApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new world with the specified settings. This does not yet load the world.     **Required permissions:**    - **world.create**   
         * @summary Create a world
         * @param {CreateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld(body?: CreateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).createWorld(body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Deletes an existing world. **The world must be unloaded before deleting it**     **Required permissions:**    - **world.delete**   
         * @summary Delete a world
         * @param {string} world The uuid of the world to delete
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).deleteWorld(world, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Provides direct access to the underlaying world object and can execute any method on it.     **Required permissions:**    - **world.method**   
         * @summary Execute a method
         * @param {string} world The uuid of the world on which to execute the method
         * @param {ExecuteMethodRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMethod(world: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).executeMethod(world, body, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get detailed information about a world.     **Required permissions:**    - **world.one**   
         * @summary Get a world
         * @param {string} world The uuid of the world for which to get details
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).getWorld(world, details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Get a list of all the worlds on the server.     **Required permissions:**    - **world.list**   
         * @summary List worlds
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorlds(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).listWorlds(details, accept, pretty, options)(fetch, basePath);
        },
        /**
         * Modify the properties of an existing world.     **Required permissions:**    - **world.modify**   
         * @summary Modify a world
         * @param {string} world The uuid of the world which to update
         * @param {UpdateWorldRequest} [body] 
         * @param {boolean} [details] Add to include additional details, omit or false otherwise
         * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
         * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWorld(world: string, body?: UpdateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
            return WorldApiFp(configuration).modifyWorld(world, body, details, accept, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * WorldApi - object-oriented interface
 * @export
 * @class WorldApi
 * @extends {BaseAPI}
 */
export class WorldApi extends BaseAPI {
    /**
     * Creates a new world with the specified settings. This does not yet load the world.     **Required permissions:**    - **world.create**   
     * @summary Create a world
     * @param {CreateWorldRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public createWorld(body?: CreateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).createWorld(body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an existing world. **The world must be unloaded before deleting it**     **Required permissions:**    - **world.delete**   
     * @summary Delete a world
     * @param {string} world The uuid of the world to delete
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public deleteWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).deleteWorld(world, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Provides direct access to the underlaying world object and can execute any method on it.     **Required permissions:**    - **world.method**   
     * @summary Execute a method
     * @param {string} world The uuid of the world on which to execute the method
     * @param {ExecuteMethodRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public executeMethod(world: string, body?: ExecuteMethodRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).executeMethod(world, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get detailed information about a world.     **Required permissions:**    - **world.one**   
     * @summary Get a world
     * @param {string} world The uuid of the world for which to get details
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public getWorld(world: string, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).getWorld(world, details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the worlds on the server.     **Required permissions:**    - **world.list**   
     * @summary List worlds
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public listWorlds(details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).listWorlds(details, accept, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Modify the properties of an existing world.     **Required permissions:**    - **world.modify**   
     * @summary Modify a world
     * @param {string} world The uuid of the world which to update
     * @param {UpdateWorldRequest} [body] 
     * @param {boolean} [details] Add to include additional details, omit or false otherwise
     * @param {'json' | 'xml'} [accept] Override the &#39;Accept&#39; request header (useful for debugging your requests)
     * @param {boolean} [pretty] Add to make the Web-API pretty print the response (useful for debugging your requests)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public modifyWorld(world: string, body?: UpdateWorldRequest, details?: boolean, accept?: 'json' | 'xml', pretty?: boolean, options?: any) {
        return WorldApiFp(this.configuration).modifyWorld(world, body, details, accept, pretty, options)(this.fetch, this.basePath);
    }

}

